#### 内存管理

##### 1.整理源文件

将不同的函数分配到不同的源文件中

<img src="D:\30daysos\diduox.gihub.io\note\09_day\屏幕截图 2024-01-10 162106.png" style="zoom:50%;" />



##### 2.内存容量检查

在最初启动时，BIOS肯定要检查内存容量，所以只 要我们问一问BIOS，就能知道内存容量有多大。

如果那样做的话，一方面asmhead.nas会 变长，另一方面，BIOS版本不同，BIOS函数的调 用方法也不相同，麻烦事太多了。所以，笔者想与 其如此，不如自己去检查内存。

###### 关于缓存：

> ​	内存与CPU的距离地与 CPU内部元件要远得多，因此在寄存器内部 MOV，要比从寄存器MOV到内存快得多。但另一 方面，有一个问题，CPU的记忆力太差了，即使知 道内存的速度不行，还不得不频繁使用内存。 考虑到这个问题，英特尔的大叔们在CPU里也加进 了一点存储器，它被称为高速缓冲存储器（cache memory）。cache这个词原是指储存粮食弹药等 物资的仓库。但是能够跟得上CPU速度的高速存储 器价格特别高，一个芯片就有一个CPU那么贵。
>
> ​	为了有效使用如此稀有的高速缓存，英特尔的大叔 们决定，每次访问内存，都要将所访问的地址和内 容存入到高速缓存里。也就是存放成这样：18号地 址的值是54。如果下次再要用18号地址的内容， CPU就不再读内存了，而是使用高速缓存的信息， 马上就能回答出18号地址的内容是54。
>
> ​	往内存里写入数据时也一样，首先更新高速缓存的 信息，然后再写入内存。如果先写入内存的话，在 等待写入完成的期间，CPU处于空闲状态，这样就 会影响速度。所以，先更新缓存，缓存控制电路配 合内存的速度，然后再慢慢发送内存写入命令。
>
> ​	观察机器语言的流程会发现，9成以上的时间耗费 在循环上。所谓循环，是指程序在同一个地方来回 打转。所以，那个地方的内存要一遍又一遍读进 来。从第2圈循环开始，那个地方的内存信息已经 保存到缓存里了，就不需要执行费时的读取内存操 作了，机器语言的执行速度因而得以大幅提高。 另外，就算是变量，也会有像“for(i = 0; i < 100; i++){}”这样，i频繁地被引用，被赋值的情况，最 初是０，紧接着是１，下一个就是２。也就是说， 要往内存的同一个地址，一次又一次写入不同的 值。缓存控制电路观察会这一特性，在写入值不断 变化的时候，试图不写入缓慢的内存，而是尽量在 缓存内处理。循环处理完成，最终i的值变成100以 后，才发送内存写入命令。这样，就省略了99次内 存写入命令，CPU几乎不用等就能连续执行机器语 言。

<img src="D:\30daysos\diduox.gihub.io\note\09_day\屏幕截图 2024-01-10 162911.png" style="zoom:67%;" />





内存检查时，要往内存里随便写入一个值，然后马 上读取，来检查读取的值与写入的值是否相等。如 果内存连接正常，则写入的值能够记在内存里。如 果没连接上，则读出的值肯定是乱七八糟的。方法 很简单。

但是，如果CPU里加上了缓存会怎么样 呢？写入和读出的不是内存，而是缓存。结果，所 有的内存都“正常”，检查处理不能完成。

首先，暂时让486以后的CPU的高速缓存 （cache）功能无效。当CPU里加上了缓存，写入和读出的不是内存，而是缓存。结果，所有的内存都“正常”，检查处理不能完成。

所以，只有在内存检查时才将缓存设为OFF。具体 来说，就是先查查CPU是不是在486以上，如果 是，就将缓存设为OFF。按照这一思路，我们创建 了以下函数memtest。

**本次的bootpack.c节选**

```c
#define EFLAGS_AC_BIT 0x00040000 //标志寄存器的位
#define CR0_CACHE_DISABLE 0x60000000 //CR0的缓存禁用位
unsigned int memtest(unsigned int start,unsigned int end)
{
	char flg486 = 0;
	unsigned int eflg, cr0, i;
    
	// --------------确认CPU是386还是486以上的 ----------------------------------------
	eflg = io_load_eflags();
	eflg |= EFLAGS_AC_BIT; // AC-bit = 1 将AC位设为1
	io_store_eflags(eflg);//储存AC位
	eflg = io_load_eflags();//读取AC位
	if ((eflg & EFLAGS_AC_BIT) != 0) { /* 如果是386，即使设定AC=1，AC的值还会自动回到0 */
        flg486 = 1;//代表是486CPU
	}
    //------------------------------------------------------------------------------
	eflg &= ~EFLAGS_AC_BIT; //通过按位与反操作 将AC位清零（相同为1 不同为0）
	io_store_eflags(eflg);//将AC位存进去
	if (flg486 != 0) {//如果是有缓存功能的486
		cr0 = load_cr0();//取出状态
		cr0 |= CR0_CACHE_DISABLE; /*禁止缓存*/
		store_cr0(cr0);//放入状态
	}
	i = memtest_sub(start, end);//执行真正的内存检测操作 返回的是内存的大小            
	if (flg486 != 0) {
		cr0 = load_cr0();//放入状态
		cr0 &= ~CR0_CACHE_DISABLE; /* 允许缓存*/
		store_cr0(cr0);//取出状态
	}
	return i;
}
```

memtest_sub函数，是内存检查处理的实现 部分

```c
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i, *p, old, pat0 = 0xaa55aa55,pat1 = 0x55aa55aa;//这两个值还是什么内存测试惯用值什么的......
	for (i = start; i <= end; i += 4) {//i + 4是因为每次要检查4个字节
		p = (unsigned int *) i;
		old = *p; //储存写入之前的值
		*p = pat0; /* 试写 */
		*p ^= 0xffffffff; //用异或来实现反转
		if (*p != pat1) { //检查反转结果
			not_memory://没有恢复
				*p = old;
				break;
		}
		*p ^= 0xffffffff; /* 再次反转 */
		if (*p != pat0) { /* 检查值是否恢复 */
			goto not_memory;//没有恢复
		}
		*p = old; /* 恢复为修改前的值*/
	}
	return i;
}
```

这是一个简单的内存测试函数 `memtest_sub`，用于测试指定范围内的内存是否可写和可读。

本次的bootpack.c节选

```c
unsigned int memtest_sub(unsigned int start, unsigned int end)//此函数返回的是能到达的最后一个字节
{
	unsigned int i, *p, old, pat0 = 0xaa55aa55,
	pat1 = 0x55aa55aa;
	for (i = start; i <= end; i += 0x1000) {//每次检查4kb 
		p = (unsigned int *) (i + 0xffc);//检查这4kb末尾的4byte
		old = *p; /* 先记住修改前的值*/
```

让我们稍微做一点改良，让其一次增加 0x1000 即4kb，并且从检验前四个字节改变为检验末尾的四个字节，来保证内存大小测量的准确性。

改造HariMain

```c
i = memtest(0x00400000, 0xbfffffff) / (1024 *1024);//以MB的方式来显示
sprintf(s, "memory %dMB", i);
putfonts8_asc(binfo->vram, binfo->scrnx, 0, 32,COL8_FFFFFF, s);

```

***卧槽出BUG了***

哎？怎么回事？内存容量怎么不是32MB，而是 3072MB？这不就是3GB吗？为什么会失败呢？明 明已经将缓冲OFF掉了。

玛德，想起来当初写并发的时候，一共卖10000张票，直接被编译器优化没了,都看不到超卖现象了ww                        

##### 2.内存容量检查（2）

harib06b中，memtest_sub的编译结果

```assembly
_memtest_sub:
	PUSH EBP ; C编译器的固定语句
	MOV EBP,ESP
	MOV EDX,DWORD [12+EBP] ; EDX = end;
	MOV EAX,DWORD [8+EBP] ; EAX = start;
	/* EAX是i */
	CMP EAX,EDX ; if (EAX >EDX) goto L30;
	JA L30
	L36:
	L34:
		ADD EAX,4096 ; EAX +=0x1000;
		CMP EAX,EDX ; if (EAX <=EDX) goto L36;
		BE L36
	L30:
		POP EBP ; 接收前文中PUSH的EBP
		RET ; return;
```

***所有的异或、取反语句都被编译器优化没了***

因为编译器认为，在C语言中，所有的比较都是一定成立的。所以将其都优化没了。

为解决这个问题，我们可以更改编译选项，也可以直接利用汇编来进行写代码。

如果更改编译选项，是可以停止最优化处理的。可 是在其他地方，我们还是需要如此考虑周密的最优 化处理的，所以不想更改编译选项。 

在此，作者采用汇编代码来代替C语言的功能。

本次的naskfunc.nas节选

```assembly
_memtest_sub: ; unsigned int
memtest_sub(unsigned int start, unsigned intend)
    PUSH EDI ; （由于还要使用EBX, ESI, EDI）
    PUSH ESI
    PUSH EBX
    MOV ESI,0xaa55aa55 ; pat0= 0xaa55aa55;
    MOV EDI,0x55aa55aa ; pat1= 0x55aa55aa;
    MOV EAX,[ESP+12+4] ; i =start;
    mts_loop:
        MOV EBX,EAX
        ADD EBX,0xffc ; p = i+ 0xffc;
        MOV EDX,[EBX] ; old =*p;
        MOV [EBX],ESI ; *p =pat0;
        XOR DWORD [EBX],0xffffffff ; *p ^=0xffffffff;
        CMP EDI,[EBX] ; if(*p != pat1) goto fin;
        JNE mts_fin
        XOR DWORD [EBX],0xffffffff ; *p ^=0xffffffff;
        CMP ESI,[EBX] ; if(*p != pat0) goto fin;
        JNE mts_fin
        MOV [EBX],EDX ; *p = old;
        ADD EAX,0x1000 ; i += 0x1000;
        CMP EAX,[ESP+12+8] ; if (i <= end) goto mts_loop;
        JBE mts_loop
        POP EBX
        POP ESI
        POP EDI
        RET
     mts_fin:
            MOV [EBX],EDX ; *p = old;
            POP EBX
            POP ESI
            POP EDI
            RET

```

##### 3.挑战内存管理

```c
//以4kb为1单位管理 写入0或者1来标记哪里是空着的，哪里是正在使用的。
char a[32768];
for (i = 0; i < 1024; i++) {
	a[i] = 1; /* 一直到4MB为止，标记为正在使用 */
}
for (i = 1024; i < 32768; i++) {
	a[i] = 0; /* 剩下的全部标记为空 */
}
```

比如需要100KB的空间，那么只要从a中找出连续 25个标记为0的地方就可以了。

```c
j = 0;
again:
	for (i = 0; i < 25; i++) {
		if (a[j + i] != 0) {
			j++;
			if (j < 32768 - 25) goto again;//太怪了 第一次看到大循环写里面 小循环写外边的
			//运行到这里就代表没有足够内存了
		}
	}
			printf("代表着从a[j]到a[j + 24]为止，标记连续为0");
```

如果找到了标记连续为0的地方，暂时将这些地方 标记为“正在使用”，然后从j的值计算出对应的地 址。这次是以0x1000字节为管理单位的，所以将j 放大0x1000倍就行了。

```c
for (i = 0; i < 25; i++) {
	a[j + i] = 1;
}
printf("从 j * 0x1000 开始的100KB空间得到分配");
//地址等于 j * 0x1000(4kb)
```

释放内存

```c
//将地址对应成内存管理的编号
//j = 地址 / 0x1000
j = 0x00123000 / 0x1000;//找到起点
for (i = 0; i < 25; i++) {
	a[j + i] = 0;
}
```

此方法的管理表大小为: 内存 / 0x1000 即为内存的0.02%

此比例和内存的大小无关

------

除了这个管理方法之外，还有一种列表管理的方 法，是把类似于“从xx号地址开始的yy字节的空间是空着的”这种信息都列在表里。

```c
struct FREEINFO { /*储存每个内存段的信息*/
	unsigned int addr, size;
};
struct MEMMAN { /*整体内存管理结构体*/
	int frees;
	struct FREEINFO free[1000];
};
struct MEMMAN memman;
memman.frees = 1; /* 可用状况list中只有1件*/
memman.free[0].addr = 0x00400000; 	/* 本内存段从0x00400000号地址开始 */
memman.free[0].size = 0x07c00000;	/* 本内存段的大小为124MB */
```

寻找可用空间

```c
for (i = 0; i < memman.frees; i++) {
	if (memman.free[i].size >= 100 * 1024) {
		"找到可用空间！";
		"从地址memman.free[i].addr开始的100KB空间，可以使用哦！";
	}
}
"没有可用空间";
memman.free[i].addr += 100 * 1024; /* 可用地址向后推进了100KB */
memman.free[i].size -= 100 * 1024; /* 减去100KB*/
```

如果size变成了0，那么这一段可用信息就不再需要 了，将这条信息删除，frees减去1就可以了。

而 且，还要调查一下这段新释放出来的内存，与相邻 的可用空间能不能连到一起。如果能连到一起，就 把它们归纳为一条。

本次的bootpack.c节选

```c
#define MEMMAN_FREES 4090 /* 大约是32KB*/
struct FREEINFO { /* 可用信息 */
	unsigned int addr, size;
};
struct MEMMAN { /* 内存管理 */
	int frees, maxfrees, lostsize, losts;
	struct FREEINFO free[MEMMAN_FREES];
};
void memman_init(struct MEMMAN *man)
{
	man->frees = 0; // 又多少可用的内存段 
	man->maxfrees = 0; // 内存段的最大个数 
	man->lostsize = 0; // 释放失败的内存的大小总和 
	man->losts = 0; //放失败次数 
	return;
}
unsigned int memman_total(struct MEMMAN *man)
/* 报告空余内存大小的合计 */
{
	unsigned int i, t = 0;
	for (i = 0; i < man->frees; i++) {
		t += man->free[i].size;
	}
	return t;
}
unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
/* 分配 */
{
	unsigned int i, a;
	for (i = 0; i < man->frees; i++) {
		if (man->free[i].size >= size) {
			/* 找到了足够大的内存 */
			a = man->free[i].addr;		//记录该程序
			man->free[i].addr += size;//该内存段的可用地址起点
			man->free[i].size -= size;//该内存段的可用空间大小
			if (man->free[i].size == 0) {//如果这个内存段全部都被分配出去了
				man->frees--;
				for (; i < man->frees; i++) {//将后面的编号全部减少一位
					man->free[i] = man->free[i+ 1]; 
				}
			}
			return a;
		}
	}
	return 0; /* 没有可用空间 */
}
```

是往memman里追加可用内存信息的函数

在这个特定的实现中，归纳和合并是以整个可用内存块为最小单位的。

这意味着不能将一个大的可用内存块分割成多个小块。（总是要有取舍的wwwww）

```c
//传入 要释放内存块的起始地址和释放大小
int memman_free(struct MEMMAN *man, unsigned,int addr, unsigned int size)
/* 释放 */
{
	int i, j;
    
	for (i = 0; i < man->frees; i++) {
		if (man->free[i].addr > addr) {//找到一个起始地址大于addr的内存块
			break;
		}
	}
    //当找到的不是第一个内存块时
	if (i > 0) {
		//如果可以和前面结合
  		//判断条件为：前面内存块的起始地址 + 前面内存块的内存大小 = 待插入内存块的起始地址
		if (man->free[i - 1].addr + man->free[i - 1].size == addr) {
			man->free[i - 1].size += size;
			if (i < man->frees) {//如果后面还有内存块
				//判断条件为：待插入内存块的起始地址 + 待插入内存块的内存大小 = 后面内存块的起始地址
				if (addr + size == man->free[i].addr) {	// 也可以与后面的可用内存归纳到一起 *
					man->free[i - 1].size +=man->free[i].size;
                    //此时前 + 待插入 + 后三个块合为1个，free块数-1
					man->frees--;
					for (; i < man->frees; i++)
					{//后边的编号全部-1
						man->free[i] = man->free[i + 1]; 
					}
				}
			}
			return 0; /* 成功完成 */
		}
	}
	/* 不能与前面的可用空间归纳到一起 */
	if (i < man->frees) {
		/* 后面还有 */
		if (addr + size == man->free[i].addr) {
			/* 可以与后面的内容归纳到一起 */
			man->free[i].addr = addr;
			man->free[i].size += size;
			return 0; /* 成功完成 */
		}
	}
	/* 既不能与前面归纳到一起，也不能与后面归纳到一起 */
	if (man->frees < MEMMAN_FREES) {
		for (j = man->frees; j > i; j--) {//全都向后移动一位 给i留出位置
			man->free[j] = man->free[j - 1];
		}
		man->frees++;//内存块数量+1
		if (man->maxfrees < man->frees) {
			man->maxfrees = man->frees; /* 更新最大值 */
		}
        //新建储存块
		man->free[i].addr = addr;
		man->free[i].size = size;
		return 0; /* 成功完成 */
	}
    //储存失败的统计信息
	//之前没有retuen出去
	man->losts++;
	man->lostsize += size;
	return -1; /* 失败 */
}
```

本次的bootpack.c节选

最后，将这个程序应用于HariMain，结果就变成了 下面这样。写着“（中略）”的部分，笔者没做修 改。

```c
#define MEMMAN_ADDR 0x003c0000//MEMMAN_ADDR的内存地址 （32kb结构体）
void HariMain(void)
{
	（中略）
	unsigned int memtotal;//内存总量
	struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
	（中略）
	memtotal = memtest(0x00400000, 0xbfffffff);//检查可用的内存
	memman_init(memman);//初始化meman
	memman_free(memman, 0x00001000,0x0009e000); //创建第一个内存段 632kb
	memman_free(memman, 0x00400000, memtotal - 0x00400000);//创建第二个内存段 28672kb
	（中略）
	sprintf(s, "memory %dMB free : %dKB",memtotal / (1024 * 1024),memman_total(memman) / 1024);
	putfonts8_asc(binfo->vram, binfo->scrnx, 0,32, COL8_FFFFFF, s);
```

