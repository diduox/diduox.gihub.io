#### 多任务（1）

##### 1.挑战任务切换

当你向CPU发出任务切换的指令时，CPU会先把寄 存器中的值全部写入内存中，这样做是为了当以后 切换回这个程序的时候，可以从中断的地方继续运 行。

接下来，为了运行下一个程序，CPU会把所有 寄存器中的值从内存中读取出来（当然，这个读取的地址和刚刚写入的地址一定是不同的，不然就相 当于什么都没变嘛），这样就完成了一次切换。我们前面所说的任务切换所需要的时间，正是对内存进行写入和读取操作所消耗的时间。

接下来我们来看看寄存器中的内容是怎样写入内存 里去的。

下面这个结构叫做“任务状态段”（task status segment），简称TSS（三姐是你吗？）。TSS有16位和32位 两个版本，这里我们使用32位版。顾名思义，TSS 也是内存段的一种，需要在GDT中进行定义后使 用。

```c
//共包含26个int成员 总共104字节
struct TSS32 {
    int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;//任务设置的相关信息（执行任务切换时，不会被写入（backlink除外，其特殊情况下会被写入））
    int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;//32位寄存器
    int es, cs, ss, ds, fs, gs;//16位寄存器
    int ldtr, iomap;//有关任务设置的部分，任务切换时不会被写入，需要赋初始值。
};
```

EIP的全称是“extended instruction pointer”，也就是“扩展指令指针寄存器”的意思。

EIP是CPU用来记录下一条需要执行的指令位于内 存中哪个地址的寄存器，因此它才被称为“指令指针”。

> 说点题外话，JMP指令实际上是一个向EIP寄存 器赋值的指令。
>
> JMP 0x1234这种写法，CPU 会解释为MOV EIP,0x1234，并向EIP赋值。
>
> 也就是说，这条指令其实是篡改了CPU记忆中下 一条该执行的指令的地址，蒙了CPU一把。这 样一来，CPU在读取下一条指令时，就会去读 取0x1234这个地址中的指令。
>
> 你看，这不就相 当于是做了一个跳转吗？ 
>
> 对了，如果你在汇编语言里用MOV EIP,0x1234这种写法是会出错的，还是不要尝试的好。
>
> 在汇编语言中，应该使用JMP 0x1234来代替MOV EIP,0x1234。

------

###### 关于JMP

JMP指令分为两种，只改写EIP的称为 near模式，同时改写EIP和CS的称为far模式。

在此 之前我们使用的JMP指令基本上都是near模式的。

**JMP DWORD 2*8:0x0000001 **	这条指令在向EIP存入0x1b的同时，将CS置为 2*8（=16）。

像这样在JMP目标地址中带冒号 （:）的，就是far模式的JMP指令

如果一条JMP指令所指定的目标地址段不是可执行的代码，而是TSS的话，CPU就不会执行通常的改写EIP和CS的操作，而是将这条指令理解为任务切换。

也就是说，CPU会切换到目标TSS所指定的任 务，说白了，就是JMP到一个任务那里去了。

> CPU每次执行带有段地址的指令时，都会去确认一下GDT中的设置，以便判断接下来要执行的 JMP指令到底是普通的 far-JMP，还是任务切换。也就是说，从汇编程序翻译出来的机器语言来看，普通的far-JMP和任务切换的far-JMP，指令本身是没有任何区别的。

------

让我们实际做一次任 务切换吧。

我们准备两个任务：任务A和任务B，尝 试从A切换到B。

- 首先，我们需要创建两个TSS：任务A的TSS和任务 B的TSS。

**本次的HariMain节选**

```c
struct TSS32 tss_a, tss_b;
```

- 向它们的ldtr和iomap分别存入合适的值。

```c
tss_a.ldtr = 0;
tss_a.iomap = 0x40000000;
tss_b.ldtr = 0;
tss_b.iomap = 0x40000000;
```

- 接着将它们两个在GDT中进行定义

**本次的HariMain节选**

```c
struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
set_segmdesc(gdt + 3, 103, (int) &tss_a, AR_TSS32);
set_segmdesc(gdt + 4, 103, (int) &tss_b, AR_TSS32);
```

将tss_a定义在gdt的3号，段长限制为103字节，tss_b定义在gdt的4号，段长限制也为103字节。

------

现在两个TSS都创建好了，该进行实际的切换了。

我们向TR寄存器存入3 * 8这个值，这是因为我们 刚才把当前运行的任务定义为GDT的3号。

TR寄存器的作用是让CPU记住当前正 在运行哪一个任务。

当进行任务切换的时候，TR寄存器的值也会自动变化，它的名字也就是“task register”（任务寄存器）的缩写。

**我们每次给TR寄存器赋值的时候，必须把GDT的编号乘以8**

给TR寄存器赋值需要使用LTR指令

**本次的HariMain节选**

```c
load_tr(3 * 8);
```

**本次的naskfunc.nas节选**

```assembly
_load_tr: 		; void load_tr(int tr);
        LTR [ESP+4] ; tr
        RET
```

LTR指令的作用只是改变TR寄存器的值，因 此执行了LTR指令并不会发生任务切换。

要进行任务切换，我们必须执行far模式的跳转指令

**本次的naskfunc.nas节选**

```assembly
_taskswitch4: ; void taskswitch4(void);
        JMP 	4*8:0
        RET
```

在切换任务之后，再返回这个任务的时候，程序会从这条JMP指令之后恢复运行，也就是执行JMP后 面的RET，从汇编语言函数返回，继续运行C语言主 程序。

如果far-JMP指令是用作任务切换的话，地址段（冒号前面的4*8的部分）要指向TSS这一点 比较重要，而偏移量（冒号后面的0的部分）并没有什么实际作用，会被忽略掉，一般来说像这样写0就可以了。

**本次的HariMain节选**

```c
} else if (i == 10) { /* 10秒计时器*/
    putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
    taskswitch4(); /*这里！ 十秒过后切换任务*/
} else if (i == 3) { /* 3秒计时器 */
```

在任务切换的时候需要读取tss_b的内容，因此我们得在 TSS中定义好寄存器的初始值才行。

**本次的HariMain节选**

```c
tss_b.eip = (int) &task_b_main; //要执行任务的地址
tss_b.eflags = 0x00000202; /* IF = 1; */
tss_b.eax = 0;
tss_b.ecx = 0;
tss_b.edx = 0;
tss_b.ebx = 0;
tss_b.esp = task_b_esp;
tss_b.ebp = 0;
tss_b.esi = 0;
tss_b.edi = 0;
tss_b.es = 1 * 8;
tss_b.cs = 2 * 8;
tss_b.ss = 1 * 8;
tss_b.ds = 1 * 8;
tss_b.fs = 1 * 8;
tss_b.gs = 1 * 8;
```

在eip中，我们需要定义在切换到这个任务的时候， 要从哪里开始运行。在这里我们先把task_b_main 这个函数的内存地址赋值给它。

**本次的bootpack.c节选**

```c
void task_b_main(void)
{
    for (;;) { io_hlt(); }
}
```

**本次的HariMain节选**

```c
int task_b_esp;

task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024;
```

**2.任务切换进阶**

刚才我们只是实现了一次性从任务A切换到任务B， 现在我们要尝试再切换回任务A。好，那我们就在 切换到任务B的5秒后，让它再切换回任务A吧。

这其实很容易，只要稍微改写一下task_b_main就 可以了。

**本次的bootpack.c节选**

```c
void task_b_main(void)
{
	struct FIFO32 fifo;
	struct TIMER *timer;
	int i, fifobuf[128];
	fifo32_init(&fifo, 128, fifobuf);
	timer = timer_alloc();
	timer_init(timer, &fifo, 1);
	timer_settime(timer, 500);
	for (;;) {
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_stihlt();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 1) { /*超时时间为5秒 */
				taskswitch3(); /*返回任务A */
			}
		}
	}
}
```

**本次的naskfunc.nas节选**

```c
_taskswitch3: ; void taskswitch3(void);
        JMP 3*8:0
        RET
```

##### 3.做一个简单的多任务

我们要创建一个通用的任务切换函数。

**本次的naskfunc.nas节选**

```assembly
_farjmp: ; void farjmp(int eip, int cs);
        JMP FAR [ESP+4] ; eip, cs
        RET
```

“JMP FAR”指令的功能是执行far跳转。在JMP FAR指令中，可以指定一个内存地址，CPU会从指 定的内存地址中读取4个字节的数据，并将其存入 EIP寄存器，再继续读取2个字节的数据，并将其存 入CS寄存器。当我们调用这个函数，比如 farjmp(eip,cs);，在[ESP+4]这个位置就存放了eip 的值，而[ESP+8]则存放了cs的值，这样就可以实 现far跳转了。

因此我们需要将调用的部分改写如下：

**taskswitch3(); → farjmp(0, 3 * 8);** 

**taskswitch4(); → farjmp(0, 4 * 8);**

现在我们来缩短切换的间隔。在任务A和任务B中， 分别准备一个timer_ts变量，以便每隔0.02秒执行 一次任务切换。这个变量名中的ts就是“task switch”的缩写，代表“任务切换计时器”的意 思。

**本次的bootpack.c节选**

```v
void HariMain(void)
{
	（中略）
	timer_ts = timer_alloc();//给计时器分配空间
	timer_init(timer_ts, &fifo, 2);//如果传入缓冲区的信号是2，则代表着是ts的计时器
	timer_settime(timer_ts, 2);//设定时间为2单位（没记错的话好像是20ms）
	（中略）
	for (;;) {
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_stihlt();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 2) {
				farjmp(0, 4 * 8);//切换到 task_b_main 函数（因为EIP寄存器，所以不是开头）
				timer_settime(timer_ts, 2);
			} else if (256 <= i && i <= 511) {
				/*键盘数据*/
				（中略）
			} else if (512 <= i && i <= 767) {
				/*鼠标数据*/
				（中略）
			} else if (i == 10) { /* 10秒计时器
			 */
			putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
			} else if (i == 3) { /* 3秒计时器*/
				putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
			} else if (i <= 1) { /*光标用计时器
			 */
			（中略）
			}
		}
	}
}
void task_b_main(void)
{
	struct FIFO32 fifo;
	struct TIMER *timer_ts;
	int i, fifobuf[128];
	fifo32_init(&fifo, 128, fifobuf);
	timer_ts = timer_alloc();
	timer_init(timer_ts, &fifo, 1);//代表该计时器的信号是1
	timer_settime(timer_ts, 2);//设定秒数
	for (;;) {
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_stihlt();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 1) { /*任务切换*/
				farjmp(0, 3 * 8);//切换过去（不是切换到开头，因为有EIP寄存器记录着执行的位置）
				timer_settime(timer_ts, 2);//重新设定时间
			}
		}
	}
}
```

##### 4.做个简单的多任务

为了确认task_b_main到底有没有运行，我们需要 让task_b_main显示点什么东西出来，最好是显示点会动的东西，要不还是让它数数吧……喂喂，是 谁在下面叫“又来了啊”？（笑）

**本次的bootpack.c节选**

```c
void task_b_main(void)
{
	struct FIFO32 fifo;
	struct TIMER *timer_ts;
	int i, fifobuf[128], count = 0;
	char s[11];
	struct SHEET *sht_back;
	（中略）
	for (;;) {
		count++;
		sprintf(s, "%10d", count);
		putfonts8_asc_sht(sht_back, 0, 144,COL8_FFFFFF, COL8_008484, s, 10);
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_sti();
		} else {
			（中略）
		}
	}
}
```

我们遇到了一个问题，那就是 sht_back。HariMain知道这个变量的值，但 task_b_main可不知道。怎么办呢？

怎样才能把这 个变量的值从任务A传递给任务B呢？随便找一个内 存地址存进去，然后再从那里读出来，这样应该可 以吧。

好，就用0x0fec这个地址，这个地址是 BOOTINFO-4。

**本次的HariMain节选**

```c
*((int *) 0x0fec) = (int) sht_back;
```

**本次的task_b_main节选**

```c
sht_back = (struct SHEET *) *((int *) 0x0fec);
```

##### 5.提高运行速度

task_b_main数数的速度即便在真机环境下运行还 是非常慢，我们得想办法提高它的运行速度。

因为我们的程序每 计1个数就在画面上显示一次，但1秒钟之内刷新 100次以上的话，人眼根本就分辨不出来，所以我 们不需要计1个数就刷新一次，只要每隔0.01秒刷新一次（切换一次刷新一次）就足够了。

**本次的bootpack.c节选**

```c
void task_b_main(struct SHEET *sht_back)
{
	struct FIFO32 fifo;
	struct TIMER *timer_ts, *timer_put;
	int i, fifobuf[128], count = 0;
	char s[12];
	fifo32_init(&fifo, 128, fifobuf);
	timer_ts = timer_alloc();
	timer_init(timer_ts, &fifo, 2);
	timer_settime(timer_ts, 2);
	timer_put = timer_alloc();
	timer_init(timer_put, &fifo, 1);
	timer_settime(timer_put, 1);
	for (;;) {
		count++;
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_sti();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 1) {
				sprintf(s, "%11d", count);
				putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11);
				timer_settime(timer_put, 1);
			} else if (i == 2) {
				farjmp(0, 3 * 8);
				timer_settime(timer_ts, 2);
			}
		}
	}
}
```

关于将sht_back的值从HariMain传递过来的方 法，*((int *) 0x0fec)这样的写法感觉实在是不好 看，于是果断废弃了，我们用栈来替代它。

举个例子，load_tr(123);这样的函数调用，如果从 汇编语言的角度来考虑的话，参数指定的数值 （123）就放在内存中，地址为ESP+4，这是C语 言的一个既定机制。

既然有这种机制，那么我们可以反过来利用一下， 也就是说，在HariMain里面这样写：

**本次的HariMain节选**

```c
task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8;
*((int *) (task_b_esp + 4)) = (int) sht_back;
```

这样一来，在任务B启动的时候，[ESP+4]这个地址 里面就已经存入了sht_back的值，因此我们就欺骗 了task_b_main，让它以为自己所接收到的 sht_back是作为一个参数传递过来的。

> 在这一节中，task_b_main已经变得像一个普通 函数一样了，但是在这个函数中千万不能使用 return。
>
> return的功能，说到底其实是返回函数被调用 位置的一个JMP指令，但这个task_b_main并不 是由某段程序直接调用的，因此不能使用 return。如果强行return的话，就会像“执行数 据”一样发生问题，程序无法正常运行。 
>
> HariMain的情况也是一样的，也禁止使用 return。 
>
> 我们在15.1节中讲过，为了记住现在正在执行 的指令所在的内存地址，需要使用EIP寄存器， 那么return的时候要返回的地址又记录在哪里 呢？对于记性不好的CPU来说，肯定会把这个 地址保存在某个地方，没错，它就保存在栈 中，地址是[ESP]。 
>
> 因此，我们不仅可以利用[ESP+4]，还可以利用 [ESP]来欺骗CPU，其实只要向[ESP]写入一个合 适的值，告诉CPU应该返回到哪个地址， task_b_main中就可以使用return了。

就是说，只有调用的函数才应该return，通过EIP指定的地址来执行函数，就不能return。

##### 6.测试运行速度

我们的程序运行得很快，可是到底有多快呢？我们 得想个办法测一下。

我们向task_b_main添加了一些代码。

**本次的bootpack.c节选**

```c
void task_b_main(struct SHEET *sht_back)
{
	struct FIFO32 fifo;
	struct TIMER *timer_ts, *timer_put,
	*timer_1s;
	int i, fifobuf[128], count = 0, count0 = 0;
	char s[12];
	（中略）
	timer_1s = timer_alloc();
	timer_init(timer_1s, &fifo, 100);
	timer_settime(timer_1s, 100);
	for (;;) {
		count++;
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_sti();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 1) {
				（中略）
			} else if (i == 2) {
				（中略）
			} else if (i == 100) {
				sprintf(s, "%11d", count - count0);//显示一下每100ms数字增加了多少
				putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11);
				count0 = count;
				timer_settime(timer_1s, 100);
			}
		}
	}
}

```

我们把这个速度和harib10i做个对比。harib10i在7 秒内计数到0099969264，即速度为每秒 14281323，相比之下性能是现在的3倍。咦，怎 么会这样？如果是2倍的话还可以理解，3倍就有点 过分了。

我们来找找原因。

每隔0.01秒刷新显示是不是不太好呢？如果显示计数是导致速度慢的原因，那干脆就别显示 了吧。

我们把开头的timer_settime （timer_put, 1）删掉，这样的话就只显示速度值了。

现在的成绩是6774100，和14281323 相比，性能差距为2.1倍，这样已经很令人满意 了。

大概JMP的地址也会影响计数的速度，另外， 如果把速度显示改成每隔5秒刷新一次，任务切换间隔再改成0.03秒的话，估计性能差距可以更加接近理想的2.0倍，不过现在这个阶段我们就不去一一尝试了

##### **7.多任务进阶**

到现在为止，我们所做的多任务都是依靠在 HariMain和task_b_main中写入负责任务切换的代码来实现的。

真正的多任务，是要做到在程序本身不知道的情况下进行任务 切换。

既然如此，我们就来为“纸娃娃系统”添加真正的多任务吧。

**本次的mtask.c节选**

```c
struct TIMER *mt_timer;
int mt_tr;
void mt_init(void)
{
	mt_timer = timer_alloc();
	/*这里没有必要使用timer_init ，因为超时过后没有必要向fifo32写入数据 */
	timer_settime(mt_timer, 2);
	mt_tr = 3 * 8;
	return;
}
void mt_taskswitch(void)//将任务切换函数从任务中独立了出来
{
	if (mt_tr == 3 * 8) {
		mt_tr = 4 * 8;
	} else {
		mt_tr = 3 * 8;
	}
	timer_settime(mt_timer, 2);
	farjmp(0, mt_tr);
	return;
}
```

下面我们来改造一下timer.c的inthandler20。

**本次的timer.c节选**

```c
void inthandler20(int *esp)
{
	char ts = 0;
	（中略）
	for (;;) {
		/* timers的计时器全部在工作中，因此不用确认flags */
        //如果没有超时 直接break
		if (timer->timeout > timerctl.count) {
			break;
		}
		/*超时*/
		timer->flags = TIMER_FLAGS_ALLOC;//更新定时器状态
		if (timer != mt_timer) {//如果超时的计时器不是mt计时器
            					//就正常读入缓冲区进行处理
			fifo32_put(timer->fifo, timer->data);
		} else {//如果超时的计时器是mt计时器
			ts = 1; /* mt_timer超时*/
		}
		timer = timer->next; /*将下一个计时器的地址赋给timer */
	}
	timerctl.t0 = timer;
	timerctl.next = timer->timeout;
	if (ts != 0) {//如果mt计时器超时了 则切换任务
		mt_taskswitch();
	}
	return;
}

```

看了上面这段代码，你可能会问，为什么要用ts这 个变量呢？

在/* 超时 */的地方直接调用 mt_taskswitch不就好了吗？也就是下面这样：

**出问题的例子**

```c
void inthandler20(int *esp)
{
	（中略）
	for (;;) {
		/* timers的计时器全部在工作中，因此不用确认flags */
		if (timer->timeout > timerctl.count) {
			break;
		}
		/*超时*/
		timer->flags = TIMER_FLAGS_ALLOC;
		if (timer != mt_timer) {
			fifo32_put(timer->fifo, timer->data);
		} else {
			mt_taskswitch();
		}
		timer = timer->next; /*将下一个计时器的地址赋给timer */
	}
	timerctl.t0 = timer;
	timerctl.next = timer->timeout;
	return;
}
```

出问题的原因在于，调用mt_taskswitch进行任务切换的时候，即便中断处理还没完成，IF（中断允许标志）的值也可能会被重设回1（因为任务切换的时候会同时切换EFLAGS）

这样可不行，在中 断处理还没完成的时候，可能会产生下一个中断请 求，这会导致程序出错。

因此我们需要采用这样的设计——等中断处理全部 完成之后，再在必要时调用mt_taskswitch。

------

接下来我们只需要将HariMain和task_b_main里面 有关任务切换的代码删掉即可。

**本次的bootpack.c节选**

```c
void task_b_main(struct SHEET *sht_back)
{
	struct FIFO32 fifo;
	struct TIMER *timer_put, *timer_1s;
	int i, fifobuf[128], count = 0, count0 = 0;
	char s[12];
	fifo32_init(&fifo, 128, fifobuf);
	timer_put = timer_alloc();
	timer_init(timer_put, &fifo, 1);
	timer_settime(timer_put, 1);
	timer_1s = timer_alloc();
	timer_init(timer_1s, &fifo, 100);
	timer_settime(timer_1s, 100);
	for (;;) {
		count++;
		io_cli();
		if (fifo32_status(&fifo) == 0) {
			io_sti();
		} else {
			i = fifo32_get(&fifo);
			io_sti();
			if (i == 1) {
				sprintf(s, "%11d", count);
				putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11);
				timer_settime(timer_put, 1);
			} else if (i == 100) {
				sprintf(s, "%11d", count - count0);
				putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11);
				count0 = count;
				timer_settime(timer_1s, 100);
			}
		}
	}
}
```

和上一节相比，为什么现在的设计可以称为“真正 的多任务”呢？因为如果使用这样的设计，即便在程序中不进行任务切换的处理（比如忘记写了，或 者因为bug没能正常切换之类的），也一定会正常完成切换。

**真正的多任务也成功了！**