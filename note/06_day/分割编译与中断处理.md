#### 分割编译与中断处理

##### 1.分割源文件

将源文件分割为几部分的利弊，大致如下。

> 优点 
>
> 1. 按照处理内容进行分类，如果分得好的话，将来 进行修改时，容易找到地方。 
>
> 2. 如果Makefile写得好，只需要编译修改过的文件，就可以提高make的速度。 
> 3.  单个源文件都不长。多个小文件比一个大文件好处理。 
> 4. 看起来很像苏联解体 : )

> 缺点
>
> 5. 源文件数量增加。 
> 6. 分类分得不好的话，修改时不容易找到地方。

我们先将源文件按下图分割一下看看。

<img src="D:\30daysos\diduox.gihub.io\note\06_day\屏幕截图 2024-01-09 193908.png" style="zoom:67%;" />

分割并不是很难，但有一点很关键。比如如果 graphic.c也想使用naskfunc.nas的函数，就必须 要写上“void io_out8（int port,int data）;”这 种函数声明。虽然这都已经写在bootpack.c里了， 但编译器在编译graphic.c时，根本不知道有 bootpack.c存在。

我们还要修改一下Makefile

<img src="D:\30daysos\diduox.gihub.io\note\06_day\屏幕截图 2024-01-09 194031.png" style="zoom:50%;" />

##### 2.整理Makefile

```makefile
#生成目标文件bootpack.gas需要bootpack.c和Makefile，这是一种依赖关系。(这意味着如果bootpack.c或Makefile中的任何一个发生了变化，那么bootpack.gas需要重新生成。)
#CC1是一个变量，这个命令的意思是使用CC1指定的编译器将bootpack.c编译为bootpack.gas。
bootpack.gas : bootpack.c Makefile
	$(CC1) -o bootpack.gas bootpack.c
	
graphic.gas : graphic.c Makefile
	$(CC1) -o graphic.gas graphic.c
	
dsctbl.gas : dsctbl.c Makefile
	$(CC1) -o dsctbl.gas dsctbl.c
```

写成一般规则的形式

```makefile
#将变量全部换成了占位符，就成了一般规则
%.gas : %.c Makefile
	$(CC1) -o $*.gas $*.c
```

make.exe会首先寻找普通的生成规则，如果没找到，就尝试用一般规则。所以，即使一般规则和普通生成规则有冲突，也不会有问题。

##### 3.整理头文件

首先将重复部分全部去掉，把他们归纳起来，放到 名为bootpack.h的文件里。虽然扩展名变了，但它 也是C语言的文件。已经有一个文件名叫 bootpack.c了，我们根据一般的做法，将文件命名 为bootpack.h。

###### bootpack.h的内容

```c
/* asmhead.nas */
struct BOOTINFO { /* 0x0ff0-0x0fff */
    char cyls; /* 启动区读硬盘读到何处为止 */
    char leds; /* 启动时键盘LED的状态 */
    char vmode; /* 显卡模式为多少位彩色 */
    char reserve;
    short scrnx, scrny; /* 画面分辨率 */
    char *vram;
};
#define ADR_BOOTINFO 0x00000ff0
/* naskfunc.nas */
void io_hlt(void);
void io_cli(void);
void io_out8(int port, int data);
int io_load_eflags(void);
void io_store_eflags(int eflags);
void load_gdtr(int limit, int addr);
void load_idtr(int limit, int addr);
/* graphic.c */
void init_palette(void);
void set_palette(int start, int end, unsigned char *rgb);
void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1);
void init_screen8(char *vram, int x, int y);
```

这个文件里不仅仅罗列出了函数的定义，还在注释 中写明了函数的定义在哪一个源文件里。想要看一 看或者修改函数定义时，只要看一下文件 bootpack.h就能知道该函数定义本身在哪个源文件 里。这就像目录一样，很方便。

在编译graphic.c的时候，我们要让编译器去读这个 头文件，做法是在graphic.c的前面加上如下一行：

```c
#include "bootpack.h"
```

编译器见到了这一行，就将该行替换成所指定文件 的内容，然后进行编译。所以，写 在“bootpack.h”里的所有内容，也都间接地写到 了“graphic.c”中。同样道理， 在“dsctbl.c”和“bootpack.c”的前面也都加上 一行“#include "bootpack.h"”。

###### 为什么这个include 用的是双引号（”“）？

**双引号（"）表示该头文件与源文件位于同一个文件夹里，**

**而尖括号（< >）则表示该头文件位于编译器所提供的文件夹里。**

#### 4.关于GDT的函数

GDTR（Global Descriptor Table Register），用于存储全局描述符表（GDT）的地址和限制。

naskfunc.nas的_load_gdtr

```assembly
_load_gdtr: ; void load_gdtr(int limit, int addr);
        MOV AX,[ESP+4] ; AX = limit
        MOV [ESP+6],AX ; [ESP + 6] = limit ([ESP + 4]是第一个变量，[ESP + 8]是第二个变量)
        LGDT [ESP+6]	;将栈中的值加载到GDTR寄存器(该方法只能读取6个字节)
        RET
```

首先，给定`limit`和`addr`的值分别为0x0000ffff和0x00270000。这两个值按照低位在内存地址小的字节中的顺序，以字节表示为：

[ESP + 4 ~ ESP + 12] = [FF FF 00 00 00 00 27 00]

执行 MOV AX,[ESP+4] ：[ESP + 4 ~ ESP + 12] = [FF FF 00 00 00 00 27 00] AX = [FF FF 00 00]

执行 MOV [ESP+6],AX ：[ESP + 4 ~ ESP + 12] = [FF FF FF FF 00 00 27 00]

执行 LGDT [ESP+6] ：LGDT[FF FF 00 00 27 00]

------

naskfunc.nas的_load_idtr设置IDTR的值，因为 IDTR与GDTR结构体基本上是一样的，程序也非常 相似。

```assembly
_load_idtr:		; void load_idtr(int limit, int addr);
		MOV		AX,[ESP+4]		; limit
		MOV		[ESP+6],AX
		LIDT	[ESP+6]
		RET
```

------

最后再补充说明一下dsctbl.c里的set_segmdesc函 数。这个有些难度，我们仅介绍一些与本书相关的 内容。

###### 本次的dsctbl.c节选

```c
struct SEGMENT_DESCRIPTOR {
	short limit_low, base_low; //4个字节
	char base_mid, access_right; //2个字节
	char limit_high, base_high; //2个字节
};
void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar)
{
	if (limit > 0xfffff) {
		ar |= 0x8000; /* G_bit = 1 */
		limit /= 0x1000;
	}
	sd->limit_low = limit & 0xffff;
	sd->base_low = base & 0xffff;
	sd->base_mid = (base >> 16) & 0xff;
	sd->access_right = ar & 0xff;
	sd->limit_high = ((limit >> 16) & 0x0f) | ((ar >> 8) & 0xf0);
	sd->base_high = (base >> 24) & 0xff;
	return;
}
```

说到底，这个函数是按照CPU的规格要求，将段的 信息归结成8个字节写入内存的。这8个字节里到底 填入了什么内容呢？昨天已经讲到，有以下3点： 

- 段的大小 
- 段的起始地址 
- 段的管理属性（禁止写入，禁止执行，系统 专用等）

> 在这个结构 体里base又分为low（2字节），mid（1字节）， high（1字节）3段，合起来刚好是32位。所以， 这里只要按顺序分别填入相应的数值就行了。虽然 有点难懂，但原理很简单。程序中使用了移位运算 符和AND运算符往各个字节里填入相应的数值。
>
> 为什么要分为3段呢？主要是为了与80286时代的 程序兼容。有了这样的规格，80286用的操作系 统，也可以不用修改就在386以后的CPU上运行 了。

> 1. **基址（base）的设计：**
>    - 使用32位表示段的地址。
>    - `base` 分为 `low`（2字节）、`mid`（1字节）、`high`（1字节）三部分，合起来刚好是32位。
>    - 通过移位运算和AND运算符，将相应的数值填入各个字节，以满足32位地址的表示和与80286时代的兼容性。
> 2. **段上限（limit）的设计：**
>    - 使用20位表示段的上限，限制最大为1MB。
>    - 为了不占满整个结构体，只能使用20位，而不是32位。
>    - 引入 `Gbit` 标志位，当 `Gbit` 为1时，`limit` 的单位解释为页（page），即4KB。
>    - 这样可以指定最大为4GB的段。
>    - `Gbit` 在段属性中，是“granularity”（颗粒度）的缩写，表示单位的大小。
>    - `limit` 的20位分别写入 `limit_low` 和 `limit_high` 中，最后高4位用于写入段属性。

------

最后再来讲一下12位的段属性。段属性又称为“段的访问权属性”，在程序中用变量名access_right 或ar来表示。因为12位段属性中的高4位放在 limit_high的高4位里，所以程序里有意把ar当作如下的16位构成来处理：

**xxxx0000xxxxxxxx(其中x是0或1)**

ar的高4位被称为“扩展访问权”。为什么这么说 呢？因为这高4位的访问属性在80286的时代还不 存在，到386以后才可以使用。

ar的低8位从80286时代就已经有了，如果要详细 说明的话，够我们说一天的了，所以这里只是简单 地介绍一下。

> **00000000（0x00）：未使用的记录表 （descriptor table）。** 
>
> **10010010（0x92）：系统专用，可读写的段。不可执行。** 
>
> **10011010（0x9a）：系统专用，可执行的段。可读不可写。** 
>
> **11110010（0xf2）：应用程序用，可读写的段。 不可执行。** 
>
> **11111010（0xfa）：应用程序用，可执行的段。 可读不可写。**

##### 5.初始化PIC

所谓PIC是“programmable interrupt controller”的缩写，意思是“可编程中断控制器”。

PIC是将8个中断信号集合成一个中断信号的装置。PIC监视着输入管脚的8个中断信号，只要有一 个中断信号进来，就将唯一的输出管脚信号变成 ON，并通知给CPU。IBM的大叔们想要通过增加 PIC来处理更多的中断信号，他们认为电脑会有8个 以上的外部设备，所以就把中断信号设计成了15 个，并为此增设了2个PIC。

与CPU直接相连的PIC称为主PIC（master PIC），与主PIC相连的PIC称为从PIC（slave PIC）。主PIC负责处理第0到第7号中断信号，从 PIC负责处理第8到第15号中断信号。

另外，从PIC通过第2号IRQ与主PIC相连。主板上 的配线就是这样，无法用软件来改变。

<img src="D:\30daysos\diduox.gihub.io\note\06_day\屏幕截图 2024-01-09 223814.png" style="zoom: 67%;" />

###### init.c的主要组成成分

```c
void init_pic(void)
/* PIC的初始化 */
{
	io_out8(PIC0_IMR, 0xff ); /* 禁止所有中断*/
	io_out8(PIC1_IMR, 0xff ); /* 禁止所有中断*/
	io_out8(PIC0_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */
	io_out8(PIC0_ICW2, 0x20 ); /* IRQ0-7由INT20-27接收 */
	io_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2连接 */
	io_out8(PIC0_ICW4, 0x01 ); /* 无缓冲区模式*/
	io_out8(PIC1_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */
	io_out8(PIC1_ICW2, 0x28 ); /* IRQ8-15由INT28-2f接收 */
	io_out8(PIC1_ICW3, 2 ); /* PIC1由IRQ2连接 */
	io_out8(PIC1_ICW4, 0x01 ); /* 无缓冲区模式*/
	io_out8(PIC0_IMR, 0xfb ); /* 11111011PIC1以外全部禁止 */
	io_out8(PIC1_IMR, 0xff ); /* 11111111 禁止所有中断 */
	return;
}
```

------

1. **IMR（Interrupt Mask Register）：**
   - IMR 是 8 位寄存器，用于屏蔽 IRQ（中断请求）信号。
   - 每一位对应一个 IRQ 信号，如果某一位的值是 1，则相应的 IRQ 信号被屏蔽，PIC 将忽视该信号。
   - 用于在修改中断设定期间防止混乱，以及防止未连接设备的 IRQ 引起的静电干扰等。
2. **ICW（Initialization Control Word）：**
   - ICW 包括 4 个字节，分别编号为 1~4。
   - ICW1 和 ICW4 与 PIC 主板配线方式、中断信号的电气特性等有关，通常设定为固定值。
   - ICW3 用于关联主 PIC 与从 PIC，以及从 PIC 与主 PIC 的连接。在此程序中，设定为 `00000100`。
   - ICW2 决定了 IRQ 通知 CPU 的中断号。
3. **ICW2 中断号的设定：**
   - PIC 利用传送 2 个字节的数据来设定中断号，通过 `IN` 或 `OUT` 进行数据传送。
   - 数据信号线连在一起，PIC 通过传送 `0xcd 0x??` 这两个字节来设定中断号，这样 CPU 就会执行 `INT 0x??` 指令，是以INT 0x20~0x2f接收中断信号IRQ0~15 而设定的。
   - 这样的设计是为了绕过 `INT 0x00~0x1f`，以防止应用程序对操作系统进行破坏。

##### 6.中断处理程序的制作

鼠标是 IRQ12，键盘是IRQ1，所以我们编写了用于INT 0x2c和INT 0x21的中断处理程序（handler），即 中断发生时所要调用的程序。

###### int.c的节选

```c
void inthandler21(int *esp)//目前还暂时不用esp
/* 来自PS/2键盘的中断 */
{
	struct BOOTINFO *binfo = (struct BOOTINFO*) ADR_BOOTINFO;
	boxfill8(binfo->vram, binfo->scrnx,COL8_000000, 0, 0, 32 * 8 - 1, 15);
	putfonts8_asc(binfo->vram, binfo->scrnx, 0,0, COL8_FFFFFF, "INT 21 (IRQ-1) : PS/2 keyboard");
		for (;;) {
			io_hlt();
		}
}
```

中 断处理完成之后，不能执行“return;”（=RET指 令）， 而是必须执行IRETD指令，真不好办。而 且，这个指令还不能用C语言写2。所以，还得借助 汇编语言的力量修改naskfunc.nas。

###### 本次的naskfunc.nas节选

```assembly
        EXTERN _inthandler21, _inthandler2c ;声明外部函数（等讲到call的时候再说）
_asm_inthandler21:
        PUSH ES
        PUSH DS
        PUSHAD
        MOV EAX,ESP
        PUSH EAX
        MOV AX,SS
        MOV DS,AX
        MOV ES,AX
        CALL _inthandler21 ;调用函数的指令
        POP EAX
        POPAD
        POP DS
        POP ES
        IRETD
```

`PUSHAD` 是 x86 汇编语言中的指令，用于将通用寄存器的值（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）一次性压入堆栈。

```assembly
PUSH EAX
PUSH ECX
PUSH EDX
PUSH EBX
PUSH ESP
PUSH EBP
PUSH ESI
PUSH EDI
```

`POPAD` 是 x86 汇编语言中的指令，与 `PUSHAD` 相对应，用于从堆栈中弹出通用寄存器的值并恢复它们的状态

```assembly
POP EDI
POP ESI
POP EBP
POP ESP
POP EBX
POP EDX
POP ECX
POP EAX
```

------

好了，这样_asm_inthandler21的讲解就没有问题 了吧。下面要说明的，就是要将这个函数注册到 IDT中去这一点。我们在dsctbl.c的init_gdtidt里加 入以下语句。

```c
/* IDT的设定 */
set_gatedesc(idt + 0x21, (int)asm_inthandler21, 2 * 8, AR_INTGATE32);
set_gatedesc(idt + 0x2c, (int)asm_inthandler2c, 2 * 8, AR_INTGATE32);
```

asm_inthandler21注册在idt的第0x21号。这样， 如果发生中断了，CPU就会自动调用 asm_inthandler21。这里的2 * 8表示的是 asm_inthandler21属于哪一个段，即段号是2，乘 以8是因为低3位有着别的意思，这里低3位必须是 0。

不过，号码为2的段，究竟是什么样的段呢？

```c
set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK,AR_CODE32_ER);
```

程序中有以上语句，说明这个段正好涵盖了整个 bootpack.hrb。 最后的AR_INTGATE32将IDT的属性，设定为 0x008e。它表示这是用于中断处理的有效设定。

还有就是对bootpack.c的HariMain的补 充。“io_sti();”仅仅是执行STI指令，它是CLI的逆 指令。就是说，执行STI指令后，IF（interrupt flag，中断许可标志位）变为1，CPU接受来自外 部设备的中断（参考4.6节）。CPU的中断信号只 有一根，所以IF也只有一个，不像PIC那样有8位。 在HariMain的最后，修改了PIC的IMR，以便接受 来自键盘和鼠标的中断。这样程序就完成了。只要 按下键盘上某个键，或动一动鼠标，中断信号就会 传到CPU，然后CPU执行中断处理程序，输出信 息。