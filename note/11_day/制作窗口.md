#### 制作窗口

##### 1.鼠标显示问题

<img src="D:\30daysos\diduox.gihub.io\note\11_day\屏幕截图 2024-01-12 112416.png" style="zoom:50%;" />

当我们把鼠标移到右侧的时候，我们会发现鼠标的一部分并没有在画面的外部被隐藏起来，但是在我们的Windows系统中，鼠标的一部分是应该被隐藏起来的。

**HariMain.c**

```c
if (mx > binfo->scrnx - 16) {
	mx = binfo->scrnx - 16;
}
if (my > binfo->scrny - 16) {
	my = binfo->scrny - 16;
}
```

我们发现是这个限制设置的太宽了，我们将其改的窄一点。

```C
if (mx > binfo->scrnx - 1) {
	mx = binfo->scrnx - 1;
}
if (my > binfo->scrny - 1) {
	my = binfo->scrny - 1;
}
```

​	**卧槽，又bug了**

<img src="D:\30daysos\diduox.gihub.io\note\11_day\屏幕截图 2024-01-12 112937.png" style="zoom:50%;" />

##### 2.实现画面外支持

怎么才能让图层位于画面以外时也不出问题呢？因 为只有sheet_refreshsub函数在做把图层内容写入 VRAM的工作，所以我们决定把这个函数做得完美 一些，让它不刷新画面以外的部分。（这下segmentation fault了）

**本次的sheet.c节选**

```c
void sheet_refreshsub(struct SHTCTL *ctl, int
	vx0, int vy0, int vx1, int vy1)
{
	int h, bx, by, vx, vy, bx0, by0, bx1, by1;
	unsigned char *buf, c, *vram = ctl->vram;
	struct SHEET *sht;
	/* 如果refresh的范围超出了画面则修正 */
	if (vx0 < 0) { vx0 = 0; }
	if (vy0 < 0) { vy0 = 0; }
	if (vx1 > ctl->xsize) { vx1 = ctl->xsize; }
	if (vy1 > ctl->ysize) { vy1 = ctl->ysize; }
	for (h = 0; h <= ctl->top; h++) {
		//（中略）
	}
	return;
}

```

##### 3 shtctl的指定省略

其实本质上就是在每个图层中，都内置了一个图层管理系统，这样的画，就不用每次都指定ctl了。

**本次bootpack.h节选**

```c
struct SHEET {
    unsigned char *buf;
    int bxsize, bysize, vx0, vy0, col_inv, height, flags;
    struct SHTCTL *ctl;
};

```

```c
struct SHTCTL *shtctl_init(struct MEMMAN
	*memman, unsigned char *vram, int xsize, int
	ysize)
{
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)
	memman_alloc_4k(memman, sizeof (struct SHTCTL));//分配了这么多内存真是财大气粗了
	if (ctl == 0) {
		goto err;
	}
	ctl->vram = vram;
	ctl->xsize = xsize;
	ctl->ysize = ysize;
	ctl->top = -1; /* 没有一张SHEET */
	for (i = 0; i < MAX_SHEETS; i++) {
		ctl->sheets0[i].flags = 0; /* 未使用标记 */
		ctl->sheets0[i].ctl = ctl; /* 记录所属*/ /* 这里！ */
	}
	err:
		return ctl;
}
```

##### 4.显示窗口

就是又手搓一个窗口界面

**本次的bootpack.c节选**

```c
void make_window8(unsigned char *buf, int xsize, int ysize, char *title)
{
    //x图形的字符画hh
	static char closebtn[14][16] = {
		"OOOOOOOOOOOOOOO@",
		"OQQQQQQQQQQQQQ$@",
		"OQQQQQQQQQQQQQ$@",
		"OQQQ@@QQQQ@@QQ$@",
		"OQQQQ@@QQ@@QQQ$@",
		"OQQQQQ@@@@QQQQ$@",
		"OQQQQQQ@@QQQQQ$@",
		"OQQQQQ@@@@QQQQ$@",
		"OQQQQ@@QQ@@QQQ$@",
		"OQQQ@@QQQQ@@QQ$@",
		"OQQQQQQQQQQQQQ$@",
		"OQQQQQQQQQQQQQ$@",
		"O$$$$$$$$$$$$$$@",
		"@@@@@@@@@@@@@@@@"
	};
	int x, y;
	char c;
    //窗口本身
	boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 );
	boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 );
	boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1);
	boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2);
	boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2);
	boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1);
	boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3);
	boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 );
	boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2);
	boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1);
    //用于写标题的函数
	putfonts8_asc(buf, xsize, 24, 4,COL8_FFFFFF, title);
    //画叉的函数
	for (y = 0; y < 14; y++) {
		for (x = 0; x < 16; x++) {
			c = closebtn[y][x];
			if (c == '@') {
				c = COL8_000000;
			} else if (c == '$') {
				c = COL8_848484;
			} else if (c == 'Q') {
				c = COL8_C6C6C6;
			} else {
				c = COL8_FFFFFF;
			}
			buf[(5 + y) * xsize + (xsize - 21 + x)] = c;
		}
	}
	return;
}
```

我们在HariMain里也添加了一些内容。因为功能很 简单，所以添加的内容不多。

**本次的bootpack.c节选**

```c
void HariMain(void)
{
	（中略）
	struct SHEET *sht_back, *sht_mouse, *sht_win; /* 这里！ 创建了三个图层*/
	unsigned char *buf_back, buf_mouse[256], *buf_win; /* 这里！ 保存三个图层的地址*/
	//（中略）
	init_palette();
	shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);
	sht_back = sheet_alloc(shtctl);
	sht_mouse = sheet_alloc(shtctl);
	sht_win = sheet_alloc(shtctl); /* 这里！给图层分配内存空间*/
	buf_back = (unsigned char *)
	memman_alloc_4k(memman, binfo->scrnx * binfo- >scrny);
	buf_win = (unsigned char *)
	memman_alloc_4k(memman, 160 * 68); /* 这里！ 给缓冲区分配内存空间*/
	sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /* 没有透明色 */
	sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);
	sheet_setbuf(sht_win, buf_win, 160, 68,-1); /* 没有透明色 */ /* 这里！ 设定新建窗口的缓冲区*/
	init_screen8(buf_back, binfo->scrnx, binfo->scrny);
	init_mouse_cursor8(buf_mouse, 99);
	make_window8(buf_win, 160, 68, "window");/* 这里！ 之前构造的专门用于新建窗口的函数*/
	putfonts8_asc(buf_win, 160, 24, 28, COL8_000000, "Welcome to"); /* 这里！ 在win窗口中显示字符*/
	putfonts8_asc(buf_win, 160, 24, 44, COL8_000000, " Haribote-OS!"); /* 这里！ 在win窗口中显示字符*/
	sheet_slide(sht_back, 0, 0);
	mx = (binfo->scrnx - 16) / 2; /* 为使其处于画面的中央位置，计算坐标 */
	my = (binfo->scrny - 28 - 16) / 2;
	sheet_slide(sht_mouse, mx, my);
	sheet_slide(sht_win, 80, 72); /* 这里！ 设置当有窗口在此窗口上滑动时的刷新方法*/
	sheet_updown(sht_back, 0);
	sheet_updown(sht_win, 1); /* 这里！ 设置图层的高度*/
	sheet_updown(sht_mouse, 2);
	sprintf(s, "(%3d, %3d)", mx, my);
	putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);
	sprintf(s, "memory %dMB free : %dKB", memtotal / (1024 * 1024), memman_total(memman) / 1024);
	putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);
	sheet_refresh(sht_back, 0, 0, binfo->scrnx, 48);
	（中略）
}
```

##### 5 小实验（harib08e）

这一节我们来做一个小实验。HariMain中有设置图 层高度的地方，如果像下面这样，把窗口图层放在 最上面，光标图层放在其次，会变成什么样呢？

```c
sheet_updown(sht_back, 0);
sheet_updown(sht_mouse, 1);
sheet_updown(sht_win, 2);
```

<img src="D:\30daysos\diduox.gihub.io\note\11_day\屏幕截图 2024-01-12 140507.png" style="zoom:50%;" />

##### 6.高速计数器

实验顺利结束了，我们还把图层的高度设置恢复原 样，然后再试着做个动作更丰富的窗口。做成什么 样呢？我们就做一个能够计数，并将计数结果显示 出来的窗口吧。计数器在英语中是counter，所以 我们就将窗口的名称改为counter。 我们只改写了10行就得到了下面这个程序。

其实就是将窗口的文字显示改成for循环，每循环一次，记一个数。（所以叫高速计数器嘛www）

**PS：这样写计数器给我电脑写死机了......**

**本次的bootpack.c节选**

```c
void HariMain(void)
{
	struct BOOTINFO *binfo = (struct BOOTINFO*) ADR_BOOTINFO;
	char s[40], keybuf[32], mousebuf[128];
	int mx, my, i;
	unsigned int memtotal, count = 0; /* 这里！记数变量*/
	struct MOUSE_DEC mdec;
	struct MEMMAN *memman = (struct MEMMAN *)
	MEMMAN_ADDR;
	struct SHTCTL *shtctl;
	struct SHEET *sht_back, *sht_mouse,
	*sht_win;
	unsigned char *buf_back, buf_mouse[256],
	*buf_win;
	（中略）
	init_palette();
	shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);
	sht_back = sheet_alloc(shtctl);
	sht_mouse = sheet_alloc(shtctl);
	sht_win = sheet_alloc(shtctl);
	buf_back = (unsigned char *)
	memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);
	buf_win = (unsigned char *)
	memman_alloc_4k(memman, 160 * 52); /* 这里！ 更改了窗口的大小*/
	sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /* 没有透明色 */
	sheet_setbuf(sht_mouse, buf_mouse, 16, 16,99);
	sheet_setbuf(sht_win, buf_win, 160, 52,-1); /* 没有透明色 */ /* 这里！  也是更改了窗口的大小*/
	init_screen8(buf_back, binfo->scrnx, binfo->scrny);
	init_mouse_cursor8(buf_mouse, 99);
	make_window8(buf_win, 160, 52, "counter");/* 这里！ 更改了窗口大小和标题*/
	sheet_slide(sht_back, 0, 0);
	mx = (binfo->scrnx - 16) / 2; /* 为使其处于画面中央位置，计算坐标 */
	my = (binfo->scrny - 28 - 16) / 2;
	sheet_slide(sht_mouse, mx, my);
	sheet_slide(sht_win, 80, 72);
	sheet_updown(sht_back, 0);
	sheet_updown(sht_win, 1);
	sheet_updown(sht_mouse, 2);
	sprintf(s, "(%3d, %3d)", mx, my);
	putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);
	sprintf(s, "memory %dMB free : %dKB", memtotal / (1024 * 1024), memman_total(memman) / 1024);
	putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);
	sheet_refresh(sht_back, 0, 0, binfo->scrnx,48);
	for (;;) {
		count++; /* 从这里开始 */
		sprintf(s, "%010d", count);//没想到这里也能用格式化输出
		boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43);
		putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s);
		sheet_refresh(sht_win, 40, 28, 120,44); /* 到这里结束 这里刷新了范围内的所有区域*/
		io_cli();
		if (fifo8_status(&keyfifo) +fifo8_status(&mousefifo) == 0) {
			io_sti(); /* 不做HLT */
		} else {
			//（中略）这里就是检查中断的
		}
	}
}
```

怎么总觉得显示的内容在闪烁呢？

这可不行。 为什么会出现这种现象呢？

这是由于在刷新的时 候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，所以肯定就会闪烁了。

##### 7 消除闪烁（1）

发生闪烁的原因是刷新范围是此区域的所有图层，即使背景图层没有变化，也要刷新。

综上所述，仅对refresh对象及其以上的图层进行刷 新就可以了。那么我们赶紧按照这个思路修改程序 吧。

**本次的sheet.c节选**

```c
void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)
{
		//（中略）
	for (h = h0; h <= ctl->top; h++) {//从本层到最顶层
		//（中略）
	}
	return;
}
```

我们追加了h0参数，只对在此参数以上的图层进行 刷新。然后还要把所有调用了sheet_refreshsub的 函数都修改一下。 

**本次的sheet.c节选**

```c
void sheet_refresh(struct SHEET *sht, int bx0,int by0, int bx1, int by1)
{
	if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */
	sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1,sht->height);/*这里！ 添加了h0变量*/
	}
	return;
}

void sheet_slide(struct SHEET *sht, int vx0,int vy0)
{
	int old_vx0 = sht->vx0, old_vy0 = sht->vy0;
	sht->vx0 = vx0;
	sht->vy0 = vy0;
	if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新*/
	sheet_refreshsub(sht->ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht- >bysize, 0);/*刷新移动起点的图层，因为可能出现因上方图层移动而露出底下图层的情况，所以要从第0层开始刷新*/
	sheet_refreshsub(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height);/*刷新移动终点的图层，因为只有可能出现影响上面的情况，所以从本层开始刷新*/
	}
	return;
}
void sheet_updown(struct SHEET *sht, int height)
{
	（中略）
	/* 以下主要是对sheets[]的重新排列 */
	if (old > height) { /* 比以前低 */
		if (height >= 0) {
			/* 中间的提起 */
			for (h = old; h > height; h--) {
				ctl->sheets[h] = ctl->sheets[h - 1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
			/* 这里 只重写上面改变的图层*/ sheet_refreshsub(ctl, sht->vx0,sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height + 1);
		} else { /* 隐藏 */
			if (ctl->top > old) {
				/* 把上面的降下来 */
				for (h = old; h < ctl->top; h++) {
					ctl->sheets[h] = ctl->sheets[h + 1];
					ctl->sheets[h]->height = h;
				}
			}
			ctl->top--; /* 正在显示的图层减少了一个，故最上面的高度也减少 */
			/* 这里 从下向上刷新所有的图层*/ sheet_refreshsub(ctl, sht->vx0,sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0);
		}
	} else if (old < height) { /* 比以前高 */
		if (old >= 0) {
			/* 中间的图层往下降一层 */
			for (h = old; h < height; h++) {
				ctl->sheets[h] = ctl->sheets[h + 1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
		} else { /* 从隐藏状态变为显示状态 */
			/* 把在上面的图层往上提高一层 */
			for (h = ctl->top; h >= height; h--) {
				ctl->sheets[h + 1] = ctl->sheets[h];
				ctl->sheets[h + 1]->height = h + 1;
			}
			ctl->sheets[height] = sht;
			ctl->top++; /* 显示中的图层增加了一个，故最上面的高度也增加 */
		}
		sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height);/* 这里 刷新从这往上的图层*/
	}
	return;
}
```

**闪烁现象消失了**

不错，性能越来越完善了。哎？等等，怎么稍微一 动，鼠标就又出问题了！

**鼠标变得一闪一闪的**

数字部分的背景闪烁问题是解决了，可是把鼠标放 在上面时，鼠标又闪烁起来了（不过，从截图看不出来）。嗯，这可是个问题。

##### 8 消除闪烁（2）

当我们鼠标放在数字上的时候，被鼠标遮蔽的区域就不应该刷新，这样就可以解决闪烁问题了。并且如果鼠标下面不用刷新了，那么鼠标本身也就不用进行刷新操作了。

这样也不行，那样也不行，左思右想之后我们决定 采用下面这种方法。首先，开辟一块内存，**大小和VRAM一样**，我们先称之为map（地图）吧。至于 为什么要叫做地图，我们马上就来讲解。 

**本次的bootpack.h和sheet.c程序的节选**

```c
struct SHTCTL {
	unsigned char *vram, *map; /* 这里！ 加入了map变量*/
	int xsize, ysize, top;
	struct SHEET *sheets[MAX_SHEETS];
	struct SHEET sheets0[MAX_SHEETS];
};
struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)
{
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(memman, sizeof (struct SHTCTL));
	if (ctl == 0) {//如果ctl内存分配失败了
		goto err;
	}
	/* 从这里开始 */
	ctl->map = (unsigned char *)
	memman_alloc_4k(memman, xsize * ysize);
	if (ctl->map == 0) {//如果map内存分配失败了
		memman_free_4k(memman, (int) ctl, sizeof (struct SHTCTL));
		goto err;
	}
	/* 到这里结束 */
	ctl->vram = vram;
	ctl->xsize = xsize;
	ctl->ysize = ysize;
	ctl->top = -1; /* 没有一张SHEET */
	for (i = 0; i < MAX_SHEETS; i++) {
		ctl->sheets0[i].flags = 0; /* 未使用标记 */
		ctl->sheets0[i].ctl = ctl; /* 记录所属 */
	}
	err:
		return ctl;
}
```

这块内存用来表示画面上的点是哪个图层的像素， 所以它就相当于是图层的地图。

<img src="D:\30daysos\diduox.gihub.io\note\11_day\屏幕截图 2024-01-12 150017.png" style="zoom:50%;" />

当刷新图层1的时候，如果一边看着这个map一边 刷新的话，就不必担心图层1和图层2重叠的部分被 覆盖了。

下面我们来写向map中写入1、2等图层号码的函 数。

**本次的sheet.c节选**

```c
void sheet_refreshmap(struct SHTCTL *ctl, int
	vx0, int vy0, int vx1, int vy1, int h0)
{
	int h, bx, by, vx, vy, bx0, by0, bx1, by1;
	unsigned char *buf, sid, *map = ctl->map;
	struct SHEET *sht;
	if (vx0 < 0) { vx0 = 0; }
	if (vy0 < 0) { vy0 = 0; }
	if (vx1 > ctl->xsize) { vx1 = ctl->xsize; }
	if (vy1 > ctl->ysize) { vy1 = ctl->ysize; }
	for (h = h0; h <= ctl->top; h++) {
		sht = ctl->sheets[h];
		sid = sht - ctl->sheets0; /* 将进行了减法计算的地址作为图层号码使用 这里真是太酷了 把sheets0看成地址变量（其实应该是最初的地址变量被看作了数组）*/
		buf = sht->buf;
		bx0 = vx0 - sht->vx0;
		by0 = vy0 - sht->vy0;
		bx1 = vx1 - sht->vx0;
		by1 = vy1 - sht->vy0;
		if (bx0 < 0) { bx0 = 0; }
		if (by0 < 0) { by0 = 0; }
		if (bx1 > sht->bxsize) { bx1 = sht->bxsize; }
		if (by1 > sht->bysize) { by1 = sht->bysize; }
		for (by = by0; by < by1; by++) {
			vy = sht->vy0 + by;
			for (bx = bx0; bx < bx1; bx++) {
				vx = sht->vx0 + bx;
				if (buf[by * sht->bxsize + bx] != sht->col_inv) {
					map[vy * ctl->xsize + vx] = sid;//如果不是透明的地方 放入map层数 由于是低到高绘制map所以不用担心被低层覆盖的问题
				}
			}
		}
	}
	return;
}
```

下面是sheet_refreshsub函数。我们对它进行改 写，让它可以使用map。

**本次的sheet.c节选**

```c
void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)
{
	int h, bx, by, vx, vy, bx0, by0, bx1, by1;
	unsigned char *buf, *vram = ctl->vram, *map = ctl->map, sid;
	struct SHEET *sht;
	/* 如果refresh的范围超出了画面则修正*/
	（中略）
	for (h = h0; h <= h1; h++) {
		sht = ctl->sheets[h];
		buf = sht->buf;
		sid = sht - ctl->sheets0;
		/* 利用vx0～vy1，对bx0～by1进行倒推 */
		（中略）
		for (by = by0; by < by1; by++) {
			vy = sht->vy0 + by;
			for (bx = bx0; bx < bx1; bx++) {
				vx = sht->vx0 + bx;
				if (map[vy * ctl->xsize + vx]== sid) {//只有图层和当前map编号一致，才进行刷新
					vram[vy * ctl->xsize + vx]= buf[by * sht->bxsize + bx];
				}
			}
		}
	}
	return;
}
```

现在我们来修改调用了sheet_refreshsub的3个函 数，先从较短的2个入手吧。

**本次的sheet.c节选**

```c
void sheet_refresh(struct SHEET *sht, int bx0,int by0, int bx1, int by1)
{
    //由于刷新一个图层这种基本操作并不涉及图层的移动，或者优先级的改变
    //所以我们没有必要在这里进行map的刷新
	if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */
	sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 +by1, sht->height, sht->height);
	}
	return;
}
void sheet_slide(struct SHEET *sht, int vx0, int vy0)
{
	struct SHTCTL *ctl = sht->ctl;
	int old_vx0 = sht->vx0, old_vy0 = sht->vy0;
	sht->vx0 = vx0;
	sht->vy0 = vy0;
	if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */
        //先要刷新起点和终点处的 map 再刷新图层
	sheet_refreshmap(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize,0);
	sheet_refreshmap(ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height);
	sheet_refreshsub(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0 ,sht->height - 1);
	sheet_refreshsub(ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height,sht->height);
	}
	return;
}

```

最后是sheet_updown函数，此函数通过改变图层的高度，来影响图层的map属性。 

**本次的sheet.c节选**

```c 
void sheet_updown(struct SHEET *sht, int
	height)
{
	（中略）
	/* 下面主要是对sheets[]进行重新排列 */
	if (old > height) { /* 比以前低 */
		if (height >= 0) {
			/* 中间的图层也提高一层 */
			（中略）
			sheet_refreshmap(ctl, sht->vx0,sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 +sht->bysize, height + 1);
			sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height + 1, old);
		} else { /* 隐藏 */
			（中略）
			sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0);
			sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0, old - 1);
		}
	} else if (old < height) { /* 比以前高 */
		（中略）
		sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize,height);
		sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize,height, height);
	}
	return;
}

```

