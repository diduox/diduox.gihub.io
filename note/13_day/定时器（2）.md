#### 定时器（2）

##### 1.简化字符串显示

浏览一下harib09g的bootpack.c，大家会发现它 居然有210行之长。这中间多次出现了如下内容：

```c
boxfill8(buf_back, binfo->scrnx, COL8_008484, 0, 16, 15, 31);
putfonts8_asc(buf_back, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
sheet_refresh(sht_back, 0, 16, 16, 32);
```

众所周知，每当我们要在屏幕上显示一串字符串，我们就要先用背景颜色将其覆盖，然后在上面写上对应的字符串，之后再刷新图层，所以我们完全可以将其整合为一个操作。

```c
void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l)
{
	boxfill8(sht->buf, sht->bxsize, b, x, y, x + l * 8 - 1, y + 15);
	putfonts8_asc(sht->buf, sht->bxsize, x, y, c, s);
	sheet_refresh(sht, x, y, x + l * 8, y + 16);
	return;
}

```

然后我们对bootpack.c的所有相应 地方进行替换即可。

##### 2.重新调整FIFO缓冲区（1）

**改写前的HariMain节选**

```c
if (fifo8_status(&keyfifo) +fifo8_status(&mousefifo) + fifo8_status(&timerfifo) + fifo8_status(&timerfifo2) + fifo8_status(&timerfifo3) == 0) {
	io_sti();
} else {
```

我们发现每有一个定时器，就会出现一个缓冲区，这完全是没有必要的（之前出现这种状况，只是为了统一状况，方便处理）。

所以我们可以将不同定时器的内容写入同一个缓冲区，通过写入信息的不同，来判断具体是哪一个定时器超时了。

**本次的HariMain节选**

```c
fifo8_init(&timerfifo, 8, timerbuf);
timer = timer_alloc();
timer_init(timer, &timerfifo, 10);//10s 后超时就写成10（根据之前的init函数，写入时间的时候，会自动排序）
timer_settime(timer, 1000);
timer2 = timer_alloc();
timer_init(timer2, &timerfifo, 3);
timer_settime(timer2, 300);
timer3 = timer_alloc();
timer_init(timer3, &timerfifo, 1);
timer_settime(timer3, 50);
```

我们对if语句也进行相应的修改吧。 

**本次的HariMain节选**

```c
for (;;) {
	sprintf(s, "%010d", timerctl.count);
	putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10);
	io_cli();
	if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {
		io_sti();
	} else {
		if (fifo8_status(&keyfifo) != 0) {
			（中略）
		} else if (fifo8_status(&mousefifo) != 0) {
			（中略）
		} else if (fifo8_status(&timerfifo) != 0) {
			i = fifo8_get(&timerfifo); /*取出最近的超时定时器*/
			io_sti();
			if (i == 10) {
				putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
			} else if (i == 3) {
				putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
			} else {
				//闪烁光标计时器
				if (i != 0) {
					timer_init(timer3, &timerfifo, 0); /*下面是设定为0 */
					boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);
				} else {
					timer_init(timer3, &timerfifo, 1); /*下面是设定为1*/
					boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);
				}
				timer_settime(timer3, 50);
				sheet_refresh(sht_back, 8, 96, 16, 112);
			}
		}
	}
}
```

##### 3.测试性能

从昨天开始，我们就在不断地对定时器进行改善， 而且以后还要继续改善，但我们不能总是自我满足 呀，我们要亲自感受一下到底改善到什么程度了。 所以我们要测试性能。

我们之所以如此专注于定时器的改良，理由很简 单，是因为在今后的开发中会经常使用定时器。经 常使用的东西当然要做好。同理，我们也努力地改 进了图层控制程序。（越基础的东西越要写的精简）

测试性能的方法很简单：先对HariMain略加修改， 恢复变量count，然后完全不显示计数，全力执 行“count++；”语句。当到了10秒后超时的时 候，再显示这个count值。程序所做的只有这么 多。可是需要注意，必须在起动3秒后把count复位 为0一次。为什么要这样做呢？我们在后面的专栏 里说明。

**本次的HariMain节选**

```c
int mx, my, i, count = 0;
（中略）
for (;;) {
	count++; /* 这里！ */
	io_cli();
	if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {
		io_sti();
	} else {
		if (fifo8_status(&keyfifo) != 0) {
			（中略）
		} else if (fifo8_status(&mousefifo) != 0) {
			（中略）
		} else if (fifo8_status(&timerfifo) != 0) {
			i = fifo8_get(&timerfifo); /* 超时的是哪个呢？ */
			io_sti();
			if (i == 10) {
				putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
				sprintf(s, "%010d", count); /*  这里！ 超时的时候读入当前的计数*/
				putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10); /* 这里！打印出当时的数值*/
			} else if (i == 3) {
				putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
				count = 0; /* 开始测定 */
			} else {
				/* 0还是1 */
				if (i != 0) {
					timer_init(timer3, &timerfifo, 0); /* 下面是设定为0 */
					boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);
				} else {
					timer_init(timer3, &timerfifo, 1); /* 下面是设定为1 */
					boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);
				}
				timer_settime(timer3, 50);
				sheet_refresh(sht_back, 8, 96, 16, 112);
			}
		}
	}
}

```

**PS：顺便提一下，在我的实机上运行的时候，得到的数字大了10倍左右，可能是CPU主频太高的缘故。**

**用“make run”运行5次harib10c的结果**

```
0002638668
0002639649
0002638944
0002648179
0002637604
```

5次结果是如此发散，是由于使用模拟器而受到了 Windows的影响。5次结果中，最大值与最小值的 差有10575之大。因此我们在真机上也执 行“make install”看看。

**用真机执行5次harib10c的结果**

```
0074643522
0074643698
0074643532
0074643699
0074643524
```

靠按复位按钮完成多次起动，的确很麻烦，我们只 做了5次。得到的数值收敛得很好，最大值和最小 值的差只有177。果然还是真机好呀。虽然用了真 机，可还是出现了177的误差，其原因在于电脑内 部的温度変化，或时钟频率的微妙変化。

**大家可以看出，程序每改良一次速度就提高一点。**

------

**起动3秒后，将count置为0 的原因**

> 首先考虑一下这个命令的意思吧。起动3秒后把 count复位至0，这与从3秒后开始计数是一样 的。画面上要到10秒以后才显示，这样测试的时间就是7秒钟。
>
> 事实上，笔者最初并没有加入“count=0;”语句。但那样做的结果是，在真机上测定harib10d时，最高值和最低值的差值竟然达到 了150054。这可了不得呀。差值这么大，即使 我们比较harib10c和harib10d，也不知道哪个更快。
>
> 对于这样的结果，笔者曾茫然不知所措，差一点要放弃性能比较。但后来笔者忽然想起，只 要某些条件稍微有些变化，电脑初始化所花费的时间就会有很大变化。这就是为什么我们在 起动后3秒钟之内不进行测试的原因。这样做之后，误差急剧减小，终于可以比较结果了，真是太好了。

##### 5.重新调整FIFO缓冲区（2）

既然可以把3个定时器归纳到1个FIFO缓冲区里， 那是不是可以把键盘和鼠标都归纳起来，只用1个 FIFO缓冲区来管理呢？

如果能够这样管理的话，程序就可以写成：

```
if (fifo32_status(&fifo) == 0)
```

在13.2节中，通过往FIFO内写入不同的数据，我们 可以把3个定时器归入1个FIFO缓冲区里。同理， 分别将从键盘和鼠标输入的数据也设定为其他值就可以了。那好，我们就这么办。

- **0～ 1…………………光标闪烁用定时器**
- **3…………………3秒定时器**
- **10…………………10秒定时器** 
- **256～ 511…………………键盘输入（从键盘控制器读入的值再加上256）** 
- **512～ 767……鼠标输入（从键盘控制器读入的值 再加上512）**

这样，1个FIFO缓冲区就可以正常进行处理了。真 是太好了！不过现在有一个问题，fifo8_put函数中 的参数是char型，所以不能指定767那样的数值。 哎，我们好不容易整理到1个缓存器中了，却又出 现这种问题。

------

所以，我们想将写入FIFO缓冲区中的内容改成能够 用int指定的形式。大家可不要担心哦。内容上与 FIFO8完全相同。只是将char型变成了int型。

**本次的bootpack.h节选**

```c
struct FIFO32 {
    int *buf;
    int p, q, size, free, flags;
};
```

**本次的fifo.c节选**

```c
void fifo32_init(struct FIFO32 *fifo, int size, int *buf)
/* FIFO缓冲区的初始化*/
{
	fifo->size = size;
	fifo->buf = buf;
	fifo->free = size; /*空*/
	fifo->flags = 0;
    //队列的两个指针
	fifo->p = 0; /*写入位置*/
	fifo->q = 0; /*读取位置*/
	return;
}
int fifo32_put(struct FIFO32 *fifo, int data)
/*给FIFO发送数据并储存在FIFO中*/
{
	if (fifo->free == 0) {
		/*没有空余空间，溢出*/
		fifo->flags |= FLAGS_OVERRUN;
		return -1;
	}
	fifo->buf[fifo->p] = data;
	fifo->p++;
	if (fifo->p == fifo->size) {
		fifo->p = 0;
	}
	fifo->free--;
	return 0;
}
int fifo32_get(struct FIFO32 *fifo)
/*从FIFO取得一个数据*/
{
	int data;
	if (fifo->free == fifo->size) {
		/*当缓冲区为空的情况下返回-1*/
		return -1;
	}
	data = fifo->buf[fifo->q];
	fifo->q++;
	if (fifo->q == fifo->size) {
		fifo->q = 0;
	}
	fifo->free++;
	return data;
}
int fifo32_status(struct FIFO32 *fifo)
/*报告已经存储了多少数据*/
{
	return fifo->size - fifo->free;
}
```

**本次的HariMain节选**

```c
struct FIFO32 fifo;//创建一个结构体
char s[40];
int fifobuf[128];
（中略）
fifo32_init(&fifo, 128, fifobuf);//初始化结构体
init_keyboard(&fifo, 256);//初始化键盘
enable_mouse(&fifo, 512, &mdec);//打开鼠标控制电路
io_out8(PIC0_IMR, 0xf8); /* 设定PIT和PIC1以及键盘为许可(11111000) */
io_out8(PIC1_IMR, 0xef); /* 设定鼠标为许可(11101111) */
//创建三个定时器
timer = timer_alloc();
timer_init(timer, &fifo, 10);
timer_settime(timer, 1000);
timer2 = timer_alloc();
timer_init(timer2, &fifo, 3);
timer_settime(timer2, 300);
timer3 = timer_alloc();
timer_init(timer3, &fifo, 1);
timer_settime(timer3, 50);
（中略）
for (;;) {
	count++;
	io_cli();
	if (fifo32_status(&fifo) == 0) {
		io_sti();
	} else {
		i = fifo32_get(&fifo);
		io_sti();
		if (256 <= i && i <= 511) { /* 键盘数据*/
		sprintf(s, "%02X", i - 256);//解码键盘数据
		putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);
		} else if (512 <= i && i <= 767) { /*鼠标数据*/
		if (mouse_decode(&mdec, i - 512) !=0) {
			/* 已经收集了3字节的数据，所以显示出来 */
			sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);
			if ((mdec.btn & 0x01) != 0) {
				s[1] = 'L';
			}
			if ((mdec.btn & 0x02) != 0) {
				s[3] = 'R';
			}
			if ((mdec.btn & 0x04) != 0) {
				s[2] = 'C';
			}
			putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15);
			/* 鼠标指针的移动 */
			mx += mdec.x;
			my += mdec.y;
			if (mx < 0) {
				mx = 0;
			}
			if (my < 0) {
				my = 0;
			}
			if (mx > binfo->scrnx - 1) {
				mx = binfo->scrnx - 1;
			}
			if (my > binfo->scrny - 1) {
				my = binfo->scrny - 1;
			}
			sprintf(s, "(%3d, %3d)", mx,my);
			putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10);
			sheet_slide(sht_mouse, mx, my);
		}
		} else if (i == 10) { /* 10秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
			sprintf(s, "%010d", count);
			putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10);
		} else if (i == 3) { /* 3秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
			count = 0; /* 开始测试 */
		} else if (i == 1) { /* 光标用定时器*/
			timer_init(timer3, &fifo, 0); /* 下面是设定0 */
			boxfill8(buf_back, binfo->scrnx,COL8_FFFFFF, 8, 96, 15, 111);
			timer_settime(timer3, 50);
			sheet_refresh(sht_back, 8, 96, 16,112);
		} else if (i == 0) { /* 光标用定时器 */
			timer_init(timer3, &fifo, 1); /* 下面是设定1 */
			boxfill8(buf_back, binfo->scrnx,COL8_008484, 8, 96, 15, 111);
			timer_settime(timer3, 50);
			sheet_refresh(sht_back, 8, 96, 16,112);
		}
	}
}
```

##### 5.加快中断处理（4）

我们发现对于缓冲区来说，我们根本利用不上顺序表的定位性质，都是从前向后查找的O(n)操作。所以我们将其改为链表，使其的插入操作变为O（1），从而节省时间复杂度。

**本次的bootpack.h节选**

```c
struct TIMER {
    struct TIMER *next;//指向下一个TIMER的地址
    unsigned int timeout, flags;
    struct FIFO32 *fifo;
    int data;
};
```

**利用next的inthandler20函数**

```c
void inthandler20(int *esp)
{
	int i;
	struct TIMER *timer;
	io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收
	  信号结束的信息通知给PIC */
	timerctl.count++;
	if (timerctl.next > timerctl.count) {
		return;
	}
	timer = timerctl.timers[0]; /* 首先把最前面的地址赋给timer */
	for (i = 0; i < timerctl.using; i++) {
		/* 因为timers的定时器都处于运行状态，所以不确认flags*/
		if (timer->timeout > timerctl.count) {
			break;
		}
		/* 超时 */
		timer->flags = TIMER_FLAGS_ALLOC;
		fifo32_put(timer->fifo, timer->data);
		timer = timer->next; /* 下一定时器的地址赋给timer */
	}
	timerctl.using -= i;
	/* 新移位 */
	timerctl.timers[0] = timer;
	/* timerctl.next的设定 */
	if (timerctl.using > 0) {
		timerctl.next = timerctl.timers[0]->timeout;
	} else {
		timerctl.next = 0xffffffff;
	}
	return;
}
```

**利用next之后的timer_settime**

```c
void timer_settime(struct TIMER *timer,
	unsigned int timeout)
{
	int e;
	struct TIMER *t, *s;
	timer->timeout = timeout + timerctl.count;
	timer->flags = TIMER_FLAGS_USING;
	e = io_load_eflags();
	io_cli();
	timerctl.using++;
	if (timerctl.using == 1) {
		/* 处于运行状态的定时器只有这一个时 */
		timerctl.timers[0] = timer;
		timer->next = 0; /* 没有下一个 */
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.timers[0];
	if (timer->timeout <= t->timeout) {
		/* 插入最前面的情况下 */
		timerctl.timers[0] = timer;
		timer->next = t; /* 下面是t */
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	/* 搜寻插入位置 */
	for (;;) {
		s = t;
		t = t->next;
		if (t == 0) {
			break; /* 最后面*/
		}
		if (timer->timeout <= t->timeout) {
			/* 插入到s和t之间时 */
			s->next = timer; /* s的下一个是timer */
			timer->next = t; /* timer的下一个是t */
			io_store_eflags(e);
			return;
		}
	}
	/* 插入最后面的情况下 */
	s->next = timer;
	timer->next = 0;
	io_store_eflags(e);
	return;
}
```

##### 6 使用“哨兵”简化程序

harib10h的timer.c程序在去除移位处理后，其中的 timer_settime函数还是有些冗长。浓缩的才是精 华，我们来想办法简化这个程序。

我们看看程序就会发现，其中有4种可能：

- **运行中的定时器只有一个的情况**
- **插入到最前面的情况**
-  **插入到s和t之间的情况**
-  **插入到最后面的情况**

**加入了哨兵**

```c
void init_pit(void)
{
	int i;
	struct TIMER *t;
	io_out8(PIT_CTRL, 0x34);
	io_out8(PIT_CNT0, 0x9c);
	io_out8(PIT_CNT0, 0x2e);
	timerctl.count = 0;
	for (i = 0; i < MAX_TIMER; i++) {
		timerctl.timers0[i].flags = 0; /* 没有使用 */
	}
	t = timer_alloc(); /* 取得一个 */
	t->timeout = 0xffffffff;
	t->flags = TIMER_FLAGS_USING;
	t->next = 0; /* 指向节点   */
	timerctl.t0 = t; /* 因为现在只有哨兵，所以他就在最前面*/
	timerctl.next = 0xffffffff; /* 因为只有哨兵，所以下一个超时时刻就是哨兵的时刻 */
	timerctl.using = 1;
	return;
}
```

由于加入了哨兵，settime的状况就变了。只有两种情况会发生：

- **插入最前面的情况** 
- **插入s和t之间的情况**

修改到这里以后，using就没什么用处了。…… using以前用于对运行中的定时器进行计数。那时 还使用数组timers[ ] ，using起过非常大的作用， 它帮助我们记录timers[ ]已被使用到了哪个位置。 另外，在不使用数组timers[ ]后，根据它是否变为 0，我们才能决定应该怎样设定next。但是现在有 了哨兵，就不会出现using为0的情况了。