#### 高分辨率及键盘输入

##### 1.继续测试性能

上次我们只测试了3个定时器的性能分析，不是很能体会出我们的链表对整体性能的优化。

所以这次我们设置500个定时器，从移位上来看出性能的变化。

**本次的bootpack.c节选**

```c
void set490(struct FIFO32 *fifo, int mode)
{
	int i;
	struct TIMER *timer;
	if (mode != 0) {
		for (i = 0; i < 490; i++) {
			timer = timer_alloc();
			timer_init(timer, fifo, 1024 + i);
			timer_settime(timer, 100 * 60 * 60 * 24 * 50 + i * 100);
		}
	}
	return;
}
```

还有，在设定HariMain的timer～timer3之前，要 先加入“set490（&fifo,1）；”语句。这样就可 以追加490个定时器了。

现在我们有三种情况：

1. **追加490个定时器时的值 set490（&fifo, 1）;**
2. **不追加490个定时器时的值 set490（&fifo, 0）;**
3. **不加入set490语句时的值**

但是，对于(2)和(3)，处理上虽然完全相同，而结 果却相差了345万左右。这个差别实在是太大了， 不可思议。

到底怎么回事儿呢？这不是程序内 容的问题，而是C编译器的问题。

实际上，由于跳 转目标地址不同，CPU的JMP指令执行的时钟周期 数也不相同。

在HariMain中，循环执 行“count++；”的for语句虽然最终被编译为 JMP指令执行，但如果前面加 上“set490（&fifo,0）；”语句，那么以后各个 指令的地址也都会相应地错开几个字节，结果造成 JMP指令的地址也略有变化。因此执行时间也稍稍 延迟，执行结果大约变差了3%。（就是说JMP的时钟周期变长了）

**for语句被编译后的结果**

```c
for(;;) { 			L2：
count++; 			count++;
任意语句; 	-> 		 任意语句;
} 					JMP L2
					这个L2的地址一旦变化，JMP的执行时间就变化！
```

##### 2.提高分辨率（1）

高分辨率的利用方法因显卡不同而不同。首先，为 了能通过“make run”运行，我们只考虑支持 QEMU模拟器的显卡。这个卡顺利运行以后，再去支持其他的显卡。

由于画面切换中我们要使用BIOS，所以就需要改写 asmhead.nas的“画面模式设定”部分了

**本次的asmhead.nas节选**

```assembly
; 设定画面模式
    MOV BX,0x4101 ; VBE的640x480x8bi彩色
    MOV AX,0x4f02
    INT 0x10
    MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）
    MOV WORD [SCRNX],640
    MOV WORD [SCRNY],480
    MOV DWORD [VRAM],0xe0000000
```

大家肯定想在真机上演示这个程序吧。可这个程序 只能在QEMU模拟器上执行。就像刚才说的，这个 程序是专门面向QEMU创建的。所以，在真机上执 行的时候，电脑还是有可能发生误动作。

在过去，电脑规格由IBM公司决定，但随着其他显卡公司技术超越IBM，出现了多样的画面模式，导致普通程序员难以应付。为解决这个问题，多家显卡公司成立了VESA协会，制定了通用的设定方法和专用的BIOS，称为VESA-BIOS扩展（VBE）。通过VBE，可以使用显卡的高分辨率功能。

**VBE的画面模式号码如下**

> 0x101……640× 480× 8bit彩色 
>
> 0x103……800× 600× 8bit彩色 
>
> 0x105……1024× 768× 8bit彩色 
>
> 0x107……1280× 1024× 8bit彩色

另外，在QEMU中不能指定最下面的 0x107。实际指定的时候，要像在asmhead.nas中 所做的那样，将以上的画面模式号码值加上 0x4000，再赋值到BX中去。不这样做就不能顺利 运行。

##### 3.提高分辨率（2）

我们不能断定真机上使用的是什么样的显卡。有的 公司尚未与VESA进行合作。如果是这种公司的产 品，由于不能使用VBE，所以大家只能忍耐一下， 使用320×200的画面了。

**本次的asmhead.nas节选**

```assembly
; 确认VBE是否存在
    MOV AX,0x9000
    MOV ES,AX
    MOV DI,0
    MOV AX,0x4f00
    INT 0x10
    CMP AX,0x004f
    JNE scrn320
```

在这里，我们给ES赋值为0x9000，给DI赋值为 0，给AX赋值为0x4f00，再执行“INT 0x10”。

如果有VBE的话，AX就会变为0x004f。要是AX没 有变为这个值，很遗憾，就只能使用320×200的 画面了。

至于为什么要对ES和DI进行赋值，是因为此显卡能 利用的VBE信息要写入到内存中以ES:DI开始的512 字节中，赋值是为了指定写入地址。

------

在“纸娃娃操作系统”中，如果VBE的版本不是2.0 以上，就不能使用高分辨率。所以我们要先调查一 下VBE的版本。

**本次的asmhead.nas节选**

```assembly
; 检查VBE的版本
    MOV AX,[ES:DI+4]
    CMP AX,0x0200
    JB scrn320 ; if (AX <0x0200) goto scrn320
```

程序进行到这里，下一步要通过VBE来查看一下画 面模式0x105能不能使用。即使VBE 的版本是VBE 2.0，也不能保证所有的画面模式都可以使用。真 是麻烦呢。

**本次的asmhead.nas节选**

```assembly
; 取得画面模式信息
    MOV CX,VBEMODE
    MOV AX,0x4f01
    INT 0x10
    CMP AX,0x004f
    JNE scrn320
```

在画面模式信息中，重要的信息有如下6个。

> **WORD [ES : DI+0x00] : 模式属性……bit7不 是1就不好办(能加上0x4000)** 
>
> **WORD [ES : DI+0x12] : X的分辨率** 
>
> **WORD [ES : DI+0x14] : Y的分辨率** 
>
> **BYTE [ES : DI+0x19] : 颜色数……必须为8** 
>
> **BYTE [ES : DI+0x1b] : 颜色的指定方法…… 必须为4 (4是调色板模式)** 
>
> **DWORD [ES : DI+0x28] : VRAM的地址**

在这6项信息当中，我们来确认如下3项：

- 颜色数是否为8 
- 是否为调色板模式 
- 画面模式号码可否加上0x4000再进行指定

**本次的asmhead.nas节选**

```assembly
; 画面模式的切换
    MOV BX,VBEMODE+0x4000
    MOV AX,0x4f02
    INT 0x10
    MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）
    MOV AX,[ES:DI+0x12]
    MOV [SCRNX],AX
    MOV AX,[ES:DI+0x14]
    MOV [SCRNY],AX
    MOV EAX,[ES:DI+0x28]
    MOV [VRAM],EAX
    JMP keystatus
```

最后的JMP指令，用来让程序跳过后面的 scrn320，而让其跳转至在BIOS中查询键盘状态的 地方。scrn320程序我们紧接着就要写。

那么当出现VBE不存在，版本不够，模式有问题的 情况下，我们又该怎么办呢？没办法，我们只能使 用迄今为止的320×200画面。

**本次的asmhead.nas节选**

```assembly
scrn320:
    MOV AL,0x13 ; VGA图、320x200x8bit彩色
    MOV AH,0x00
    INT 0x10
    MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）
    MOV WORD [SCRNX],320
    MOV WORD [SCRNY],200
    MOV DWORD [VRAM],0x000a0000
```

**4 键盘输入（1）**

再对 harib11e运行一次“make run”，然后试着 按下“A”键。按下“A”键的时候，应该显 示“1E”，键弹起的时候应该显示“9E”。

下面我们按下“B”键吧。按下的时候显 示“30”，弹起的时候显示“B0”。再按 下“C”……，这样罗列下去，可就浪费纸张了，所 以我们把这些值都归纳到下表里。表里的值是按下 键时的数值。在此基础上加上0x80就可以得到键弹 起时的数值。

<img src="D:\30daysos\diduox.gihub.io\note\14_day\屏幕截图 2024-01-14 171442.png" style="zoom:150%;" />

笔者想利用这个表实现当“A”键被按下的时候就显 示“A”。嗯，以前曾经通过计数来测试性能，现在 也已经腻了，所以我们来修改bootpack.c。不再是 让其计数，而是让其充分HLT（休眠），以便节 电。

**本次的HariMain节选**

```c
for (;;) {
	io_cli();
	if (fifo32_status(&fifo) == 0) {
		io_stihlt();
	} else {
		i = fifo32_get(&fifo);
		io_sti();
		if (256 <= i && i <= 511) { /* 键盘数据*/
		sprintf(s, "%02X", i - 256);
			putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);
		if (i == 0x1e + 256) {//如果缓冲区的值是 0x1e + 256 那么把A打印出来
			putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "A", 1);
		}
		} else if (512 <= i && i <= 767) { /*鼠标数据 */
		（中略）
		} else if (i == 10) { /* 10秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
		} else if (i == 3) { /* 3秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
		} else if (i == 1) { /* 光标用定时器 */
			（中略）
		} else if (i == 0) { /* 光标用定时器 */
			（中略）
		}
	}
}

```

**5 键盘输入（2）**

到了这一步，我们希望也能输入“B”和“C”等字 符。那么，我们来动手写程序。

```C
if (256 <= i && i <= 511) { /* 键盘数据 */
	sprintf(s, "%02X", i - 256);
	putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);
	if (i == 0x1e + 256) {
		putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "A", 1);
	}
	if (i == 0x30 + 256) {
		putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "B", 1);
	}
	if (i == 0x2e + 256) {
		putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "C", 1);
	}
	if (i == 0x20 + 256) {
		putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "D", 1);
	}
	if (i == 0x12 + 256) {
		putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "E", 1);
	}
} else if (512 <= i && i <= 767) { /* 鼠标数据 */
```

如果我们像上面这样写程序，仅仅是字母（26个） 和数字（10个），就得写36个if语句。这样做的 话，程序可就变长了。这不太好，必须要想出一个 好办法。

------

**本次的HariMain节选**

```C
static char keytable[0x54] = {
	0, 0, '1', '2', '3', '4', '5', '6',
	'7', '8', '9', '0', '-', '^', 0, 0,
	'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I',
	'O', 'P', '@', '[', 0, 0, 'A', 'S',
	'D', 'F', 'G', 'H', 'J', 'K', 'L', ';',
	':', 0, 0, ']', 'Z', 'X', 'C', 'V',
	'B', 'N', 'M', ',', '.', '/', 0, '*', 0,
	' ', 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, '7',
	'8', '9', '-', '4', '5', '6', '+', '1',
	'2', '3', '0', '.'
};
if (256 <= i && i <= 511) { /* 键盘数据 */
	sprintf(s, "%02X", i - 256);
	putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);
	if (i < 256 + 0x54) {
		if (keytable[i - 256] != 0) {
			s[0] = keytable[i - 256];
			s[1] = 0;
			putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1);
		}
	}
} else if (512 <= i && i <= 767) { /* 鼠标数据 */

```

之所以笔者把keytable[ ]设定为static char，是因 为希望程序被编译为汇编语言的时候，static char 能编译成DB指令。

##### 6.追记内容（1）

<img src="D:\30daysos\diduox.gihub.io\note\14_day\屏幕截图 2024-01-14 173933.png" style="zoom:50%;" />

我们都能实现这样的功能了

**本次的HariMain节选**

```v
int cursor_x, cursor_c;
make_textbox8(sht_win, 8, 28, 144, 16,COL8_FFFFFF);
cursor_x = 8;
cursor_c = COL8_FFFFFF;
（中略）
for (;;) {
	io_cli();
	if (fifo32_status(&fifo) == 0) {
		io_stihlt();
	} else {
		i = fifo32_get(&fifo);
		io_sti();
		if (256 <= i && i <= 511) { /* 键盘数据 */
		sprintf(s, "%02X", i - 256);
		putfonts8_asc_sht(sht_back, 0, 16,COL8_FFFFFF, COL8_008484, s, 2);
		if (i < 0x54 + 256) {
			if (keytable[i - 256] != 0 && cursor_x < 144) { /* 一般字符 */
				/* 显示1个字符就前移1次光标*/
				s[0] = keytable[i - 256];
				s[1] = 0;
				putfonts8_asc_sht(sht_win,cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1);
				cursor_x += 8;//光标向前移动
			}
		}
		if (i == 256 + 0x0e && cursor_x > 8) { /* 退格键 */
			/* 用空格键把光标消去后，后移1次光标 */
			putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, " ", 1);
			cursor_x -= 8;//光标向后移
		}
		/* 光标再显示 */
		boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);
		sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);
		} else if (512 <= i && i <= 767) { /*
		鼠标数据 */
		（中略）
		} else if (i == 10) { /* 10秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
		} else if (i == 3) { /* 3秒定时器 */
			putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
		} else if (i <= 1) { /* 光标用定时器 */
			if (i != 0) {
				timer_init(timer3, &fifo, 0);
				/* 下面设定0 */
				cursor_c = COL8_000000;//将光标变为白色
			} else {
				timer_init(timer3, &fifo, 1);
				/* 下面设定1 */
				cursor_c = COL8_FFFFFF;//将光标变为黑色
			}
			timer_settime(timer3, 50);
			boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7,43);
			sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);//刷新光标
		}
	}
}
```

##### 7.追记内容（2）

大家还记得，为了使鼠标动起来，我们付出了多少 辛苦吗？我们付出了辛苦，终于让鼠标动了起来， 可鼠标动起来后，却一点儿都没用到。它只是一个 装饰物（也许还碍手碍脚的?）。

好不容易让鼠标动起来了，我们看看能用它干些什 么吧。做什么好呢？嗯，还是来移动窗口吧。所以 下面我们就使用鼠标完成窗口移动吧。

一说到窗口的移动，感觉好像很难。但实际并不 难，只要添写4行程序就可以了。

**本次的HariMain节选**

```c
for (;;) {
	io_cli();
	if (fifo32_status(&fifo) == 0) {
		io_stihlt();
	} else {
		i = fifo32_get(&fifo);
		io_sti();
		if (256 <= i && i <= 511) { /* 键盘数据 */
		（中略）
		} else if (512 <= i && i <= 767) {
			/* 鼠标数据 * */
			if (mouse_decode(&mdec, i - 512) != 0) {
				/* 收集了3字节的数据，所以显示出来 */
				（中略）
				/* 光标移动 */
				（中略）
				sheet_slide(sht_mouse, mx,my);
				/* 从这里开始！ */ if ((mdec.btn & 0x01) !=0) {
					/* 按下左键、移动sht_win*/
					sheet_slide(sht_win, mx- 80, my - 8);
					/* 到这里结束！ */ }
			}
		} else if (i == 10) { /* 10秒定时器*/
		putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);
		} else if (i == 3) { /* 3秒定时器*/
		putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);
		} else if (i <= 1) { /* 光标用定时器*/
		（中略）
		}
	}
}
```

好了，这样就完成了。我们赶紧运行“make run”吧。启动之后，请随意在画面上某个地方点 击一下，窗口很快就移动到那里了。唰唰的感觉。 耶，太好了。